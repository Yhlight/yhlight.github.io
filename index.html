<!DOCTYPE html>
<html>
<head>
<title>java笔记.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E4%B8%A5%E6%A0%BC%E8%AF%B4%E6%98%8E">严格说明</h1>
<ol>
<li><strong>在编程中，严格区分中英文字符，请自行安装一个英语输入法</strong></li>
<li><strong>如果你有学习过其他语言，请不要吝啬你的学识，进行一定程度的迁移运用</strong></li>
<li><strong>此篇笔记不会记录计算机基础知识</strong></li>
<li><strong>同步资料请移步https://github.com/xftxyz2001/atguigu-java</strong></li>
</ol>
<h1 id="idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE">IDEA常用快捷键</h1>
<ol>
<li><strong>CTRL+ALT+L  文件格式化（自动对齐等功能）</strong></li>
<li><strong>CTRL+/  行注释</strong></li>
<li><strong>SHIFT+F10  编译</strong></li>
</ol>
<h2 id="%E5%B8%B8%E8%A7%81%E7%9A%84dos%E5%91%BD%E4%BB%A4">常见的DOS命令</h2>
<p>WIN+R唤起运行窗口，输入CMD，打开CMD窗口<br>
如果需要使用管理员权限，需要在运行窗口输入cmd时，按下CTRL+SHIFT+ENTER，打开拥有管理员权限的CMD窗口</p>
<h3 id="dos%E5%91%BD%E4%BB%A4">DOS命令</h3>
<h4 id="%E8%BF%9B%E5%85%A5%E4%B8%8E%E5%9B%9E%E9%80%80">进入与回退</h4>
<ol>
<li>
<p>切换盘符<br>
驱动盘符号 + :<br>
将路径切换到指定的驱动盘<br>
例如：E:<br>
注意，只有访问当前盘中的路径才能够使用\yhlight这种无盘符的路径，否则需要写出盘符</p>
</li>
<li>
<p>列出文件<br>
dir + 目录<br>
列出当前目录下的文件以及文件夹<br>
例如：dir \yhlight</p>
</li>
<li>
<p>进入某目录<br>
cd + 目录<br>
例如：cd \yhlight</p>
</li>
<li>
<p>进入多级目录<br>
cd + 多级目录<br>
例如：cd \yhlight\yh-phobos-master</p>
</li>
<li>
<p>回退上一个目录<br>
cd..<br>
例如：<br>
cd \yhlight\yh-phobos-master<br>
cd..<br>
目录更新为-&gt;\yhlight</p>
</li>
<li>
<p>回退至盘符目录<br>
cd + /或\<br>
例如：cd / 或cd \</p>
</li>
<li>
<p>跨盘符访问<br>
cd + /d + 其他盘符目录<br>
例如：cd /d E:\yhlight\yh-phobos-master</p>
</li>
</ol>
<h4 id="%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4">创建与删除</h4>
<ol>
<li>
<p>创建<br>
md + 文件目录名<br>
md + 某文件<br>
例如：md \Users\yingh\yinghuolight</p>
</li>
<li>
<p>删除<br>
rd + 文件目录名<br>
rd + 某文件<br>
例如：rd xxx.txt</p>
</li>
</ol>
<h4 id="%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C">其他操作</h4>
<ol>
<li>
<p>清屏<br>
cls</p>
</li>
<li>
<p>退出命令行窗口<br>
exit</p>
</li>
<li>
<p>调用前后使用过的指令<br>
↑ ↓（键盘按键）</p>
</li>
<li>
<p>删除<br>
del + 文件目录名<br>
del + 某文件</p>
</li>
<li>
<p>删除同后缀名文件<br>
del + *.后缀<br>
例如：del *.txt</p>
</li>
</ol>
<hr>
<h2 id="java%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA">JAVA开发环境的搭建</h2>
<h3 id="jkd%E7%9A%84%E5%AE%89%E8%A3%85%E8%87%AA%E8%A1%8C%E9%80%89%E7%89%88%E6%9C%AC">JKD的安装（自行选版本）</h3>
<p>https://www.oracle.com/cn/java/technologies/downloads/<br>
进入这个链接后，你可以选择安装高版本JAVA，也可以选择安装JAVA 8<br>
需要下载的是Windows版本
<a href="https://imgse.com/i/pA3VG0U"><img src="https://s21.ax1x.com/2024/09/30/pA3VG0U.png" alt="pA3VG0U.png"></a></p>
<p>如果你想要安装JAVA 8，请继续往下浏览页面
<a href="https://imgse.com/i/pA3V8mT"><img src="https://s21.ax1x.com/2024/09/30/pA3V8mT.png" alt="pA3V8mT.png"></a></p>
<h3 id="%E8%B7%AF%E5%BE%84%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E5%BF%85%E8%A6%81">路径相关的配置（必要）</h3>
<p>JAVA可以安装在任意一个盘，只不过更推荐安装在系统盘，安装在系统盘可以避免很多问题，没必要为了担心一些微不足道的问题而安装在其他盘，具体自行选择</p>
<h3 id="java%E7%9B%AE%E5%BD%95%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86">JAVA目录的简单认识</h3>
<p><strong>bin</strong><br>
这个文件夹放着开发工具，这也是为什么编译与运行java文件要放进bin文件</p>
<p><strong>include</strong><br>
包含一些库文件</p>
<p><strong>jre（java8）</strong><br>
这个文件夹JAVA8会有，JAVA8之后的版本没有这个文件夹，高版本那边jre被打散在相关的目录中，jre这个文件夹里面放着运行时的环境文件</p>
<p><strong>legal</strong><br>
放着一些法律上的条文</p>
<p><strong>lib</strong><br>
里面放着java包，里面集成了很多指令</p>
<p><strong>conf（高版本）</strong><br>
存放一些配置文件，这些会影响java的运行</p>
<p><strong>jmods（高版本）</strong><br>
用于存放JMOD文件。这些JMOD文件是Java模块的打包格式，包含了模块的类、资源、配置文件以及其他与模块相关的信息。</p>
<p><strong>源代码</strong><br>
目录下有一个名叫src的压缩包，里面放着java的源代码，找不到不用找，反正你用不上</p>
<hr>
<h3 id="%E9%85%8D%E7%BD%AEpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">配置Path环境变量</h3>
<p><strong>什么是Path环境变量?</strong><br>
Path环境变量是window操作系统执行命令时，所要搜寻的路径</p>
<p><strong>为什么要配置Path环境变量?</strong><br>
希望在命令行使用Java工具时，在任意目录之下都能找到工具包的目录<br>
好比如说，如果没有设置Path环境变量，编译java文件需要在bin文件目录下进行<br>
例如<br>
cd C:\Program Files\Java\jdk-22\bin<br>
javac test.java<br>
java test<br>
需要这样才可以正常运行<br>
这样对开发很麻烦，肯定是不希望每次都要把java文件丢进bin目录之中再进行运行</p>
<h4 id="%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">如何配置Path环境变量?</h4>
<p>右键此电脑，属性，高级系统设置，环境变量<br>
此电脑可以在打开任意一个目录后，在左侧的总览目录中找到</p>
<p>在系统变量中，新建一个变量，名叫JAVA_HOME
变量的值为<strong>Java目录的路径</strong><br>
例如<br>
变量名 JAVA_HOME<br>
值 C:\Program Files\Java\jdk-22</p>
<p>然后在系统变量中，你可以找到Path这一栏，点击进行编辑，新建，然后粘贴这一句</p>
<blockquote>
<p>%JAVA_HOME%\bin</p>
</blockquote>
<p>之后一路返回并保存确认就好了</p>
<p>这里面其实有一个措施，可以自行选择是否弄，Path环境变量是从上往下进行读取的，为了避免其他与java相关的东西把它挤下去，你可以将它上移到最上边</p>
<hr>
<h2 id="java%E5%AD%A6%E4%B9%A0%E7%AF%87">Java学习篇</h2>
<h3 id="%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F-%E6%89%93%E5%8D%B0helloworld">你的第一个程序-打印HelloWorld</h3>
<p>Java文件是如何编写和运行的？<br>
首先，你需要通过记事本等文件软件来写Java代码，这里推荐使用<a href="https://code.visualstudio.com/">visula studio code</a></p>
<p>你只需要右键新建一个txt，然后更改为java后缀的文件，再进行编写就可以了，注意，要打开显示扩展名，否则无法进行后缀的更改</p>
<p>然后使用javac命令将java文件进行编译，生成class（字节码文件）文件</p>
<p>接着使用java命令运行生成的class文件</p>
<h3 id="helloworld%E7%9A%84%E6%89%93%E5%8D%B0">HelloWorld的打印</h3>
<p>将txt命名为HelloWorld.java，注意HelloWorld只是一个名字，可以任意更换，但是需要和代码之中的 <strong>类（class）</strong> 的名字相同，具体往下看</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(<span class="hljs-string">"HelloWorld"</span>);
    }
}
</div></code></pre>
<p>这就是打印HelloWorld需要的代码，注意，Java代码是严格区分<strong>大小写</strong>的，class后面接的HelloWorld就是<strong>类</strong>的名字，你可以随意修改，但是最好是和文件名字相同</p>
<p>举个例子<br>
文件名字 HelloWorld.java<br>
类的名字 HelloChina</p>
<p>javac HelloWorld.java<br>
生成的class是HelloChina.class</p>
<p>java HelloChina<br>
运行需要输入类的名字（要完全相同），而不是文件名字<br>
明显，这繁琐许多，同时，不仅仅是这些问题，这里进行相关的一些解析</p>
<ol>
<li>
<p>public类一致性需求<br>
你可以看到，上面的代码是class + 类名，然而，在Java中，还会使用public class + 类名<br>
在Java中规定，public class 的<strong>类名</strong>要和<strong>文件名</strong>完全相同</p>
</li>
<li>
<p>组织性，IDE支持，避免冲突等的需求</p>
</li>
</ol>
<p>说完这些，现在说一下怎么运行程序<br>
WIN+R唤起运行窗口，输入CMD，打开CMD窗口</p>
<p>如果需要使用管理员权限，需要在运行窗口输入cmd时，按下CTRL+SHIFT+ENTER，打开拥有管理员权限的CMD窗口</p>
<p>检查一下你java文件所在的位置，这里需要你有一些DOS命令的知识，文件的开头就是，这里用一个简单的例子来说明</p>
<p>d:<br>
cd D:\yhlight<br>
javac HelloWorld.java<br>
java HelloWorld</p>
<p>打印一个HelloWorld你已经学会了，接下来讨论一下一些相关问题</p>
<ol>
<li>为什么HelloWorld需要用双引号？<br>
这是字符串，字符串需要用双引号</li>
<li>可不可以打印中文<br>
当然可以！不过你要检查一下你保存的那个文件的字符编码，cmd使用的字符编码是ASNI，想要cmd正常显示中文，你需要更改你的java文件的字符编码为ASNI，请不要自作聪明，<strong>高版本</strong>是不需要设置就可以输出中文了的，只有在<strong>不行时才需要这么做</strong></li>
</ol>
<p>你可以通过以下方法进行更改</p>
<ol>
<li>记事本另存为时，更改文件的字符编码</li>
<li>设置cmd字符编码<br>
<code>chcp 65001</code></li>
<li>运行java时设置编码<br>
<code>java -Dfile.encoding=UTF-8 HelloWorld</code></li>
</ol>
<h4 id="%E6%89%93%E5%8D%B0helloworld%E4%BB%A3%E7%A0%81%E7%9B%B8%E5%85%B3%E8%A1%A5%E5%85%85">打印HelloWorld代码相关补充</h4>
<p><strong>公共类的使用</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(<span class="hljs-string">"HelloWorld"</span>);
    }
}
</div></code></pre>
<p><strong>println与print</strong><br>
System.out.println(&quot;HelloWorld&quot;);<br>
println 输出数据后<strong>进行</strong>换行</p>
<p>System.out.print(&quot;HelloWorld&quot;);<br>
print 输出数据之后<strong>不进行</strong>换行</p>
<p><strong>一个文件多个类</strong><br>
一个文件允许有多个类，但只允许一个存在一个<strong>公共类</strong>，同时，类之间不能同名</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(<span class="hljs-string">"HelloWorld"</span>);
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloJava</span> </span>{

    }

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloAlice</span> </span>{

    }
</div></code></pre>
<hr>
<h2 id="%E6%B3%A8%E9%87%8A">注释</h2>
<h3 id="%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A">单行注释 //</h3>
<p>用来解释单行代码或使某部分代码不被编译器读取<br>
// 后面跟的内容不会被编译器读取</p>
<h3 id="%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A">多行注释</h3>
<p>/*          */  两个符号间的代码全部被注释<br>
如下</p>
<pre class="hljs"><code><div><span class="hljs-comment">/*
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("HelloWorld");
    }
}
*/</span>
</div></code></pre>
<h3 id="%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8Ajava%E7%8B%AC%E6%9C%89">文档注释（java独有）</h3>
<pre class="hljs"><code><div>/**

*/
</div></code></pre>
<p>文档注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
<p>文档注释可以用来生成一套网页的介绍信息<br>
例如</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
我的首个java程序
<span class="hljs-doctag">@author</span> yinghuolight
<span class="hljs-doctag">@version</span> 1.0
*/</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>{
    <span class="hljs-comment">/**
    这是main方法，一个类可以有多个方法
    */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(<span class="hljs-string">"HelloWorld"</span>);
    }
}
</div></code></pre>
<p>使用cmd来生成需要使用以下指令</p>
<blockquote>
<p>javadoc -d mydoc -author -version HelloWorld.java</p>
</blockquote>
<p>mydoc是生成的文件夹名字，随意更改<br>
这指令只是包括了两个常用的参数，还有很多参数需要自行去探索<br>
可以尝试使用idea去生成doc文件</p>
<hr>
<h2 id="java-api%E6%96%87%E6%A1%A3">JAVA API文档</h2>
<p>API是Java提供的基本编程接口<br>
Java提供了大量的基础类，可以通过API文档来查阅</p>
<p>API地址：https://docs.oracle.com/en/java/javase/22/docs/api/index.html</p>
<p>这里拿的是java22来作为实例，你可以更换22为其他数字以查阅其他版本的API</p>
<p>也可以通过这个链接来到总览页面 https://docs.oracle.com/en/java/javase</p>
<hr>
<h3 id="%E5%AD%A6%E5%89%8D%E5%AE%9E%E4%BE%8B">学前实例</h3>
<h4 id="%E8%BE%93%E5%87%BA%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF">输出个人信息</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Introduction</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(<span class="hljs-string">"姓名：展扬呀"</span>);
        System.out.println();
        System.out.println(<span class="hljs-string">"家里蹲大学在读生，负责文案及相关程序"</span>);
        System.out.println(<span class="hljs-string">"第一次席"</span>);
    }
}
</div></code></pre>
<h2 id="%E7%AC%AC%E4%B8%80%E5%A4%A7%E7%AB%A0-%E5%8F%98%E9%87%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6">第一大章 变量与运算符</h2>
<h3 id="%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</h3>
<h4 id="%E4%BD%95%E4%B8%BA%E6%A0%87%E8%AF%86%E7%AC%A6">何为标识符</h4>
<p>Java中变量、方法、类等要素命名时使用的字符序列，称为标识符</p>
<h4 id="%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E5%87%86%E5%88%99">标识符命名准则</h4>
<ol>
<li>由26个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以作为开头</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>严格区分大小写，长度无限制</li>
<li>不能包括空格</li>
</ol>
<h4 id="%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">标识符命名规范</h4>
<p>包名：多单词组成时所有字母都小写<br>
例如: java.lang，com.atguigu.bean</p>
<p>类名、接口名：多单词组成时，所有单词的首字母大写<br>
例如: HelloWorld，String，System</p>
<p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写<br>
例如: age，name，bookName，main，binarySearch，getName</p>
<p>常量名：所有字母都大写，多单词时每个单词用下划线连接<br>
例如: MAX_VALUE，PI，DEFAULT_CAPACITY</p>
<h3 id="%E5%8F%98%E9%87%8F">变量</h3>
<h4 id="%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">变量的类型</h4>
<h5 id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</h5>
<p>整型</p>
<ol>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
</ol>
<p>浮点型</p>
<ol>
<li>float</li>
<li>double</li>
</ol>
<p>字符型</p>
<ol>
<li>char</li>
</ol>
<p>布尔型</p>
<ol>
<li>boolean</li>
</ol>
<h5 id="%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">引用数据类型</h5>
<p>类（class）<br>
数组（array）<br>
接口（interface）<br>
枚举（enum）<br>
注解（annotation）<br>
记录（record）</p>
<h4 id="%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%86%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83">定义变量的细则和规范</h4>
<p>变量：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化<br>
变量的三个要素：数据类型，变量名，存储的值<br>
变量的声明：<code>数据类型 变量名 = 变量值</code><br>
变量的意义：给一段指定的内存起名，方便操作这段内存</p>
<p>局部变量：方法内部定义的变量<br>
全局变量：方法之外定义的变量</p>
<p>作用域：变量的作用范围<br>
简单来说就是变量所在的大括号范围<br>
在这个大括号内变量可以使用<br>
全局变量的作用域是当前文件</p>
<p>生命周期：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> i;
        i = <span class="hljs-number">40</span>;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
        j = i + <span class="hljs-number">40</span>;
        <span class="hljs-keyword">int</span> sum = i + j;
        <span class="hljs-keyword">char</span> a = <span class="hljs-string">'A'</span>;
        System.out.println(i + j);
        System.out.println(<span class="hljs-string">"i + j = "</span> + sum);
        System.out.println(a);
        <span class="hljs-comment">//System.out.printf("%d", i);</span>
    }
}
</div></code></pre>
<h5 id="%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%86%E5%88%99">定义变量的细则</h5>
<ol>
<li>变量必须要先进行声明再进行使用</li>
<li>局部变量在使用之前一定要进行初始化</li>
<li>变量都有它们的作用域，出了作用域范围后无法使用</li>
<li>变量都有相应的范围，不要跃出范围</li>
</ol>
<h4 id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D">基本数据类型的介绍</h4>
<p><strong>整数类型：byte，short，int，long</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">占用存储空间</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1个字节（8个bit）</td>
<td style="text-align:center">-128 ~ 127</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2个字节</td>
<td style="text-align:center">-2^15 ~ 2^15-1</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4个字节</td>
<td style="text-align:center">-2^31 ~ 2^31-1</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8个字节</td>
<td style="text-align:center">-2^63 ~ 2^63-1</td>
</tr>
</tbody>
</table>
<p>定义long类型的变量，赋值时要以&quot;l&quot;或者&quot;L&quot;作为后缀<br>
Java程序中变量通常声明为int类型，除非范围不够<br>
Java的整型默认为int型</p>
<h5 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D">计算机的存储单位</h5>
<p><strong>字节（byte）</strong> 计算机用于计量存储容量的基本单位，一个字节等于8个bit<br>
<strong>位（比特位/bit）</strong> 数据存储的最小单位</p>
<p><strong>浮点类型：float，double</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">占用存储空间</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单精度float</td>
<td style="text-align:center">4个字节</td>
<td style="text-align:center">-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td style="text-align:center">双精度double</td>
<td style="text-align:center">8个字节</td>
<td style="text-align:center">-1.798E308 ~ 1.798E308</td>
</tr>
</tbody>
</table>
<p>浮点型有两种表现形式：<br>
十进制数：5.12，512.0f，.512<br>
科学计数法：5.12e2，512E2，100E-2</p>
<p>float尾数可以精确到7位有效数字，在很多情况下，精度很难满足<br>
double精度是float的两倍（double的精度约为15-16位）</p>
<p>定义float类型的变量，赋值要需要以&quot;f&quot;或&quot;F&quot;作为后缀<br>
Java的浮点型默认为double类型</p>
<h5 id="%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E7%9A%84%E8%AF%B4%E6%98%8E">浮点数精度的说明</h5>
<p>并不是所有的小数都能精确地用二进制浮点数表示，例如10的负次幂</p>
<p>浮点类型float，double并不适应于<strong>不容许舍入误差</strong>的金融计算，对于需要精确数字计算或者保留特定位数的精度，需要用<strong>BigDecimal</strong>类</p>
<p>一些精度相关的实例说明<br>
这个例子大多数语言都是一样的，不信去试试</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>);
    }
}
</div></code></pre>
<hr>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">float</span> ff1 = <span class="hljs-number">123123123f</span>;
        <span class="hljs-keyword">float</span> ff2 = ff1 + <span class="hljs-number">1</span>;
        System.out.println(ff1);
        System.out.println(ff2);
        System.out.println(ff1 == ff2);
    }
}
</div></code></pre>
<h5 id="%E6%B5%AE%E7%82%B9%E5%9E%8B%E5%AE%9E%E4%BE%8B">浮点型实例</h5>
<p>定义圆周率并赋值为3.14，现在有三个圆的半径为1.2，2.5，6，求它们的面积</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FloatDoubleExer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14</span>;
        <span class="hljs-keyword">double</span> r1 = <span class="hljs-number">1.2</span>;
        <span class="hljs-keyword">double</span> r2 = <span class="hljs-number">2.5</span>;
        <span class="hljs-keyword">double</span> r3 = <span class="hljs-number">6.0</span>;
        <span class="hljs-keyword">double</span> s1 = pi * r1 * r1;
        <span class="hljs-keyword">double</span> s2 = pi * r2 * r2;
        <span class="hljs-keyword">double</span> s3 = pi * r3 * r3;
        System.out.println(<span class="hljs-string">"圆1的面积为"</span> + s1 + <span class="hljs-string">" 圆2的面积为"</span> + s2 + <span class="hljs-string">" 圆3的面积为"</span> + s3);
    }
}
</div></code></pre>
<p>如果可以，请使用单词代替r1，s1</p>
<p>将华氏温度(80度)转换为摄氏度，并以华氏度和摄氏度为单位分别显示该温度<br>
<strong>℃=(℉ - 32) / 1.8</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FloatDoubleExer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">double</span> degreeFahrenheit = <span class="hljs-number">80.0</span>;
        <span class="hljs-keyword">double</span> degreeCentigrade = (degreeFahrenheit - <span class="hljs-number">32</span>) / <span class="hljs-number">1.8</span>;
        System.out.println(<span class="hljs-string">"华氏温度为"</span> + degreeFahrenheit + <span class="hljs-string">"℉"</span>);
        System.out.println(<span class="hljs-string">"摄氏温度为"</span> + degreeCentigrade + <span class="hljs-string">"℃"</span>);
    }
}
</div></code></pre>
<h4 id="%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B">字符类型</h4>
<p>char类型数据用来表示存储并表示字符，占用两个字节<br>
Java中所有字符都使用Unicode编码，故一个字符可以存储一个字母，汉字，或符号</p>
<p>字符型变量一般有四种表现形式<br>
1.使用单引号('')括起来的单个字符<br>
例如：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">char</span> c1 = <span class="hljs-string">'a'</span>;
<span class="hljs-keyword">char</span> c2 = <span class="hljs-string">'中'</span>;
<span class="hljs-keyword">char</span> c3 = <span class="hljs-string">'9'</span>;
</div></code></pre>
<p>2.直接使用Unicode值（\uXXXX）来表示字符型常量<br>
XXXX表示一个十六进制整数</p>
<p>3.Java允许使用转义字符''来将字符转变成特殊字符型常量<br>
<code>char c3 = '\n';  //\n表示换行</code><br>
人话就是转义字符</p>
<p>4.ASCII码</p>
<h4 id="%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">布尔类型</h4>
<p>boolean类型用来判断逻辑条件</p>
<p>一般用于这些场景</p>
<ol>
<li>if条件</li>
<li>while循环</li>
<li>for循环</li>
<li>do while循环</li>
</ol>
<p>boolean类型数据只有两个值：true或flase<br>
不可以使用0或非0的整数代替，这和C语言不同</p>
<p>扩展：Java虚拟机中没有任何供boolean值专用的字节码文件，在虚拟机中会把true和flase认为成int替代的整数，即0/1</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">boolean</span> isMarried = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (isMarried) {
            System.out.println(<span class="hljs-string">"不可忘却的时刻"</span>);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"友谊常在"</span>);
        }
    }
}
</div></code></pre>
<h4 id="%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99">基础数据类型运算规则</h4>
<p>基础数据类型变量间运算存在着一定的运算规则<br>
其中包括：<br>
1.类型提升<br>
2.强制类型转换<br>
3.连接</p>
<h5 id="%E7%B1%BB%E5%9E%8B%E6%8F%90%E5%8D%87">类型提升</h5>
<p>当容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据类型<br>
这个容量指的是范围大小，而不是占用的内存大小</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VariableTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> i2 = i1;
        <span class="hljs-keyword">long</span> l1 = i1;
        <span class="hljs-keyword">float</span> f1 = l1;
    }
}
</div></code></pre>
<p><code>byte,char,short -&gt; int -&gt; long -&gt; float -&gt; double</code></p>
<p>char类型之间运算照样会进行类型提升<br>
如果你的赋值操作超出原类型范围，不会发生类型提升<br>
例如：<br>
long test1 = 123123123123;<br>
123123123123没有'l'或'L'的后缀，这是int类型，按照原情况，会发生类型提升，转换成long类型，但由于这个值超出了int类型的范围，所以发生报错，没有发生类型提升，float类型不写后缀不会自动类型提升，因为浮点数默认double类型</p>
<p>整型常量默认为int类型<br>
浮点型常量默认为double类型</p>
<h4 id="%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</h4>
<p>有什么办法让范围大的类型的转变成范围小的类型？<br>
这个时候需要用到强制类型转换<br>
<code>int i1 = (int) 3.14;</code></p>
<h5 id="%E7%B2%BE%E5%BA%A6%E6%8D%9F%E5%A4%B1">精度损失</h5>
<p>强制类型转换有可能造成精度损失<br>
好比如浮点型转成整型会丢掉小数部分，这个措施叫截断</p>
<p>以下情况会发生精度损失</p>
<ol>
<li>浮点型转换整型</li>
<li>转换的类型范围过小</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> i1 = <span class="hljs-number">128</span>;
<span class="hljs-keyword">byte</span> b1 = (<span class="hljs-keyword">byte</span>) i1;
</div></code></pre>
<p>byte的范围是-128 ~ 127<br>
那么最终输出结果是多少？<br>
-128，最终输出结果是-128<br>
至于为什么，那就要了解原码反码补码（自己去了解）了</p>
<p>首先，i1是int类型，int类型占用4个字节<br>
那么它的二进制表示形式是<br>
00000000000000000000000010000000</p>
<p>而byte占用1个字节<br>
它的二进制形式只有8位<br>
只能存储10000000</p>
<p>内存中存放的是补码，打印或显示在屏幕上的是原码<br>
这里面就需要补码向原码进行转换<br>
补码等于原码取反+1，然而，对于8个二进制位的10000000来说<br>
得碍于符号位不参与运算，无法进行补码向原码进行转换<br>
于是计算机定义8位二进制10000000为-128<br>
这就是为什么最终输出结果是-128</p>
<p>等学到后面自然就知道了，这里只是简单说明</p>
<h4 id="%E8%BF%9E%E6%8E%A5">连接</h4>
<p><code>System.out.println();</code>在使用中有一个特别的运算<br>
常量或变量与字符串相加是连接在一起而不是得到运算后的结果<br>
这需要你使用括号来避免这种情况<br>
学到String类会知道<br>
好比如说</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirExer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        System.out.println(<span class="hljs-string">"abc"</span> + <span class="hljs-number">5</span> + <span class="hljs-number">5</span>);
        <span class="hljs-comment">//输出结果是abc55</span>
        System.out.println(<span class="hljs-string">"abc"</span> + (<span class="hljs-number">5</span> + <span class="hljs-number">5</span>));
        <span class="hljs-comment">//输出结果是abc10</span>
    }
}
</div></code></pre>
<h3 id="string%E7%B1%BB">String类</h3>
<p>String不属于基本数据类型，属于引用数据类型</p>
<p><code>String s1 = &quot;字符串&quot;;</code></p>
<p>字符串：由一个或多个字符组成并被双引号括起来的字符或字符串<br>
Java允许字符串为0个字符</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        String s1=<span class="hljs-string">"a"</span>;
        String s2=<span class="hljs-string">"aa"</span>;
        String s3=<span class="hljs-string">""</span>;
        String s4=<span class="hljs-string">"我是展扬"</span>;
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s3);
        System.out.println(s4);
    }
}
</div></code></pre>
<h4 id="string%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97">String与基本数据类型变量之间的运算</h4>
<p>String与基本数据类型变量都能够进行运算，但String只能与基本数据类型变量进行连接运算，使用&quot;+&quot;表示<br>
例如：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">boolean</span> b1 = <span class="hljs-keyword">true</span>;
        String s1 = <span class="hljs-string">"我是展扬"</span>;
        String s2 = s1 + b1 + num;
        System.out.println(s1 + num);
        System.out.println(s1 + b1 + num);
        <span class="hljs-comment">//不允许System.out.println(b1 + num + s1);</span>
        <span class="hljs-comment">//这违反了基本数据类型运算规则</span>
        System.out.println(s2);
    }
}
</div></code></pre>
<p>String允许与整型相连接，最终输出字符整型<br>
但在实际运用中，有可能需要让字符10恢复为数字10，这需要使用Integer类</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;
        String s1 = <span class="hljs-string">""</span>;
        String s2 = s1 + num;
        System.out.println(s2);
        <span class="hljs-comment">//最终输出"10"，字符10</span>
        <span class="hljs-keyword">int</span> num2 = Integer.parseInt(s2);
    }
}
</div></code></pre>
<h5 id="string%E7%B1%BB%E7%9A%84%E7%BB%83%E4%B9%A0">String类的练习</h5>
<p><strong>输出个人信息</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringExer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        String name = <span class="hljs-string">"Rainbow"</span>;
        <span class="hljs-keyword">int</span> age = <span class="hljs-number">21</span>;
        <span class="hljs-keyword">char</span> gender = <span class="hljs-string">'男'</span>;
        <span class="hljs-keyword">double</span> weight = <span class="hljs-number">65</span>;
        <span class="hljs-keyword">boolean</span> isMarried = <span class="hljs-keyword">false</span>;
        String phoneNumber = <span class="hljs-string">"11451419810"</span>;
        System.out.println(<span class="hljs-string">"姓名："</span> + name + <span class="hljs-string">" "</span>
                + <span class="hljs-string">"年龄："</span> + age + <span class="hljs-string">" "</span>
                + <span class="hljs-string">"性别："</span> + gender + <span class="hljs-string">" "</span>
                + <span class="hljs-string">"体重："</span> + weight + <span class="hljs-string">" "</span>
                + <span class="hljs-string">"是否已婚："</span> + isMarried + <span class="hljs-string">" "</span>
                + <span class="hljs-string">"电话号码："</span> + phoneNumber);
    }
}
</div></code></pre>
<h3 id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8">计算机的存储</h3>
<p>计算机中存储和运算的所有数据都要转为二进制，二进制是计算机的基础</p>
<p>生活中常用的进制有以下几种<br>
1.十进制<br>
数字组成：0-9<br>
进位规则：逢10进1</p>
<p>2.二进制<br>
数字组成：0-1<br>
进位规则：逢2进1，0b或0B开头（Java表示方法）</p>
<p>3.八进制<br>
数字组成：0-7<br>
进位规则：逢8进1，0开头（Java表示方法）</p>
<p>4.十六进制<br>
数字组成：0-9，a-f（不分大小写）<br>
进位规则：逢16进1，0x或0X开头</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">103</span>;
        <span class="hljs-keyword">int</span> num2 = <span class="hljs-number">0b10</span>;
        <span class="hljs-keyword">int</span> num3 = <span class="hljs-number">023</span>;
        <span class="hljs-keyword">int</span> num4 = <span class="hljs-number">0x23a</span>;
        System.out.println(num1);
        System.out.println(num2);
        System.out.println(num3);
        System.out.println(num4);
    }
}
</div></code></pre>
<h4 id="%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</h4>
<p>在Java中，这是一个二进制表示的10
0b00000000000000000000000000001010<br>
0b是Java辨识为二进制的标志<br>
00000000000000000000000000001010是10的二进制表示方法</p>
<p>int类型占用空间内存4个字节，即32个bit位，二进制里面每一位都是比特位<br>
二进制位中，最左一位是符号位，0为正，1为负<br>
00000000000000000000000000001010  //最左一位</p>
<p><strong>二进制转换十进制</strong><br>
00001010  这是10的二进制表示方法，二进制如何转换成十进制？
你可以通过以下示例来得出结论</p>
<pre class="hljs"><code><div><span class="hljs-number">1</span>*<span class="hljs-number">2</span>^<span class="hljs-number">3</span>+<span class="hljs-number">0</span>*<span class="hljs-number">2</span>^<span class="hljs-number">2</span>+<span class="hljs-number">1</span>*<span class="hljs-number">2</span>^<span class="hljs-number">1</span>+<span class="hljs-number">0</span>*<span class="hljs-number">2</span>^<span class="hljs-number">0</span>=<span class="hljs-number">10</span>

<span class="hljs-number">1</span> * <span class="hljs-number">2</span> ^ <span class="hljs-number">3</span> + <span class="hljs-number">1</span> * <span class="hljs-number">2</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">10</span>
</div></code></pre>
<p>通过上述例子你应该已经知道二进制是如何换算十进制了的</p>
<h4 id="%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81">原码反码补码</h4>
<p>原码，反码，补码<br>
数据在内存中的储存方式为补码<br>
而呈现出来的数字则是原码<br>
原码，反码，补码与二进制有关<br>
二进制位中，最左位决定正负<br>
正数的原，反，补码均不变<br>
负数的反码为符号位不变，每一位取反<br>
负数的补码为该数绝对值取反再加1</p>
<p>实例：<br>
85<br>
原码：0000000001010101<br>
反码：0000000001010101<br>
补码：0000000001010101</p>
<p>-85<br>
原码：1000000001010101<br>
反码：1111111110101010<br>
补码：1111111110101011</p>
<p>-144<br>
原码：1000000010010000<br>
反码：1111111101101111<br>
补码：1111111101110000</p>
<p>负数补码的规律是该数绝对值取反再加1<br>
综合-85及-144的补码，可以得到加1的规律为<br>
1111111110101010+0000000000000001=1111111110101011<br>
结尾为0直接变更为1<br>
1111111101101111+0000000000000001=1111111101110000<br>
当结尾为1时，加1会变为2<br>
但二进制仅由0/1组成，无法出现0/1之外的数字<br>
此时要应用逢二进一规则<br>
即本位为2时，向前进一位1，同时本位归零</p>
<p>数据存放补码的原因<br>
计算机处理器中是没有减法的处理，只是有加法的处理<br>
在计算机中相关的减法运算都是加法模拟的<br>
这一点直接说明了补码的重要性<br>
好比如说，1-1<br>
1      00000001<br>
-1     10000001<br>
1+(-1) 10000010<br>
最终结果是-2，如果使用原码来进行运算</p>
<p>如果是补码<br>
1      00000001<br>
-1     11111111<br>
1+(-1) 00000000<br>
最终结果是0</p>
<p>如果要从更深层来说，可以这么讲<br>
在计算机系统中，使用补码，可以将符号位和数值域统一处理<br>
同时，加法和减法也可以统一处理<br>
此外，补码和原码相互转换，其运算过程是相同的，不需要额外的硬件电路</p>
<h3 id="%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6">操作符/运算符</h3>
<h4 id="%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6">算术操作符</h4>
<pre class="hljs"><code><div>+    -    *    /    %
加   减   乘   除   取余
</div></code></pre>
<p><code>前置++  后置++  前置--  后置--</code><br>
++a和a++有着很大区别<br>
前后是赋值的先后，++a是先赋值，后使用<br>
a++先使用，后赋值<br>
例：<br>
int a = 10;<br>
int b = ++a;  //先赋值，后使用，b = 11</p>
<p>例如2：<br>
int a = 10;<br>
int b = a++;<br>
先使用后赋值，这里b = 10</p>
<h4 id="%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6">位操作符</h4>
<pre class="hljs"><code><div>&lt;&lt;         &gt;&gt;
左移操作符 右移操作符

&amp;      |      ^
按位与 按位或 按位异或

~  
按位取反
</div></code></pre>
<p>位操作符都是对二进制位进行更改<br>
左右移，二进制位进行左移右移，n &gt;&gt; 3表示右移三位</p>
<p>右移操作符有两种移动方式<br>
1.算术右移<br>
右边丢弃，左边补原符号位<br>
这一种用于有符号的<br>
2.逻辑右移<br>
右边丢弃，左边补零<br>
这一种用于无符号的<br>
例如：<br>
0000000000000011<br>
n &lt;&lt; 3<br>
0000000000011000</p>
<p>1111111111111101<br>
n &gt;&gt; 3<br>
1111111111111111</p>
<p>左移操作符也有这两种，只是不需要考虑符号位，只需要在右边填补0</p>
<p>按位与的作用是对两者的二进制位进行比较，若此位两者皆为0，则此位为0<br>
若此位两者分别为1,0，则此位为0，若此位两者皆为1，则此位为1，重新组成一个二进制位<br>
例如：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span> &amp; <span class="hljs-number">5</span>;  
<span class="hljs-number">3</span>   <span class="hljs-number">0000000000000011</span>  
<span class="hljs-number">5</span>   <span class="hljs-number">0000000000000101</span>  
a   <span class="hljs-number">0000000000000001</span>  
</div></code></pre>
<p>a的结果为1</p>
<p>按位或的作用是对两者的二进制位进行比较，若此位两者之中至少有一位为1，则此位为1<br>
若两者皆为0，则此位为0，重新组成一个二进制位</p>
<p>按位异或的作用对两者的二进制位进行比较，若此位两者相同，则此位为0，若此位两者不同<br>
则此位为1，重新组成一个二进制位</p>
<p>按位取反就是0变1，1变0，包括符号位</p>
<h4 id="%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6">赋值操作符</h4>
<pre class="hljs"><code><div>=   +=   -=   *=   /=   %=   &lt;&lt;=   &gt;&gt;=   &amp;=   ^=   |=
</div></code></pre>
<p>+= ^=这类属于复合赋值，具体意思对应上文再结合赋值便可知道<br>
例如 int a = 2  a = a + 5 -&gt; a += 5<br>
在Java中，+=同样可以被理解成m += 5 -&gt; m = m + 5<br>
但是不同的是，m += 5不需要考虑类型问题，Java自动更改了类型<br>
而m = m + 5则需要考虑类型提升等问题<br>
所以说下面这种会报错的情况反而是可以的<br>
这一点和C语言是不同的</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">byte</span> a = <span class="hljs-number">5</span>;
        a += <span class="hljs-number">5</span>;  <span class="hljs-comment">//允许</span>
        <span class="hljs-comment">//a = a + 5;  不允许</span>
        System.out.println(a);
    }
}
</div></code></pre>
<p>让一个数自增推荐选m += 5这种形式</p>
<h4 id="%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</h4>
<pre class="hljs"><code><div>&amp;和&amp;&amp;  |和||  !          ^
并     或者   逻辑相反    异或
</div></code></pre>
<p>&amp;是逻辑与，左右的表达式都会进行计算<br>
&amp;&amp;是短路与，当左侧满足时，右侧不再理会<br>
哈？你问为什么要写&amp;&amp;和&amp;，那是因为我一开始压根就没写&amp;</p>
<p>逻辑运算符针对的都是boolean类型的变量进行的操作<br>
逻辑运算符运算的结果也是boolean类型</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;
        <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;
        <span class="hljs-keyword">boolean</span> bo1 = (++a % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &amp;&amp; (a++ % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>);
        System.out.println(<span class="hljs-string">"a="</span> + a + <span class="hljs-string">" bo1="</span> + bo1);
        <span class="hljs-keyword">boolean</span> bo2 = (b++ % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &amp;&amp; (++b % <span class="hljs-number">7</span> == <span class="hljs-number">0</span>);
        System.out.println(<span class="hljs-string">"b="</span> + b + <span class="hljs-string">" bo2="</span> + bo2);
    }
}
</div></code></pre>
<h4 id="%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">关系运算符</h4>
<pre class="hljs"><code><div>==   !=     &gt;    &lt;    &gt;=     &lt;=
等于 不等于 大于 小于 大于等 小于等
</div></code></pre>
<p>Java中，=是赋值，==才是等于</p>
<h4 id="%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6">条件运算符</h4>
<p><code>(条件表达式)?表达式1:表达式2</code><br>
条件表达式如果是true，运算结果是表达式1，否则是2</p>
<h4 id="%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0">运算符综合练习</h4>
<p>输出某个三位数的个，十，百位</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirExer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">153</span>;
        <span class="hljs-keyword">int</span> re1 = num % <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> re2 = num / <span class="hljs-number">10</span> % <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> re3 = num / <span class="hljs-number">100</span>;
        System.out.println(re1);
        System.out.println(re2);
        System.out.println(re3);
    }
}
</div></code></pre>
<p>请问89个小时等于多少天多少小时</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirExer</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">89</span>;
        <span class="hljs-keyword">int</span> day = num / <span class="hljs-number">24</span>;
        <span class="hljs-keyword">int</span> hour = num % <span class="hljs-number">24</span>;
        System.out.println(day + <span class="hljs-string">"天"</span> + hour + <span class="hljs-string">"小时"</span>);
    }
}
</div></code></pre>
<hr>
<h2 id="scanner%E7%B1%BB">Scanner类</h2>
<p>Scanner是官方提供的一个类，用来获取和解析用户输入的数据<br>
你可以通过Scanner来获取键盘的输入</p>
<h3 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8scanner">如何使用Scanner</h3>
<p><strong>导入包</strong><br>
<code>import java.util.Scanner;</code><br>
在文件的开头书写，导入Scanner包</p>
<p><strong>创建类实例</strong><br>
<code>Scanner 变量名 = new Scanner(System.in);</code></p>
<p><strong>调用类方法</strong><br>
如果你需要接收一个字符串，你可以使用next()或nextLine()</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        String str1 = <span class="hljs-string">"荧火light"</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        str1 = scan.next();
        <span class="hljs-comment">//str1 = scan.nextLine();</span>
    }
}
</div></code></pre>
<p>next()和nextLine()的区别<br>
next()方法用于读取下一个“标记”，空格，制表符，换行符是常见的标记<br>
它会返回下一个有效字符，直到遇到空格<br>
什么意思？<br>
&quot;  Hello World&quot;，调用next()将返回&quot;Hello&quot;，下一次调用将返回&quot;World&quot;<br>
就是next()会忽略开头的空白字符，并从第一个非空白字符开始读取，直到下一个空白字符为止</p>
<p>nextLine()方法用于读取整行输入，包括空格，直到遇到换行符为止<br>
它会返回读取到的整行字符串，除了换行符<br>
&quot;Hello World&quot;，调用nextLine()将返回&quot;Hello World&quot;</p>
<p>如果你需要接收一个整型或浮点型，你需要用相应的关键词<br>
你可以在<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html">JAVA API</a>文档中查阅使用什么关键字<br>
这里简单举个例子：</p>
<pre class="hljs"><code><div>Scanner 变量名<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> Scanner(System.in);
<span class="hljs-keyword">int</span> 变量名<span class="hljs-number">2</span> = 变量名<span class="hljs-number">1</span>.nextInt();
<span class="hljs-keyword">double</span> 变量名<span class="hljs-number">2</span> = 变量名.nextDouble();
<span class="hljs-keyword">boolean</span> 变量名<span class="hljs-number">2</span> = 变量名<span class="hljs-number">1</span>.nextBoolean();
<span class="hljs-comment">//没有nextChar，如果要接收char，用next().charAt(0);</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> scanTest = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        scanTest = scan.nextInt();
        scan.close();
    }
}
</div></code></pre>
<p><strong>关闭资源</strong><br>
<code>变量名.close();</code><br>
Scanner输入流所输入的内容在运行中是不关闭的<br>
这可能会造成内存泄漏，在不需要使用Scanner时，建议关闭它</p>
<h3 id="%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B0">如何获取随机数</h3>
<p>随机数的使用是不可缺少的，在Java中可以通过Math类来生成随机数<br>
<code>double 变量名 = Math.random();</code><br>
random调用会返回一个[0.0,1.0)范围的double类型的随机数<br>
我查阅了JDK 23的API文档，这一句是Math类提供的唯一一条与随机数有关的语句<br>
如果你不想使用Math类，也可以使用Random类<a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/Random.html#%3Cinit%3E()">java.util.Random</a></p>
<p>使用Math类生成随机数需要变通一下<br>
例如：生成0-100范围的整型随机数<br>
<code>int randomNum = (int) (Math.random() * 101);</code><br>
应该能够理解为什么*101能够得出0-100的范围吧<br>
random调用会返回一个[0.0,1.0)范围的double类型的随机数<br>
*101就是[0.0,101.0)，转成int类型就是[0,100]，因为101取不到啊</p>
<p>获取[a,b]范围的通用公式<br>
<code>int 变量名 = (int) (Math.random() * (b - a + 1) + a);</code></p>
<h4 id="%E4%BD%BF%E7%94%A8random%E7%B1%BB%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0">使用Random类生成随机数</h4>
<pre class="hljs"><code><div>Random 变量名<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> Random();
<span class="hljs-comment">//括号写范围，只能写一个数字，写10就是生成[0,10)范围的整型数</span>
<span class="hljs-keyword">int</span> 变量名<span class="hljs-number">2</span> = 变量名<span class="hljs-number">1</span>.nextInt();
<span class="hljs-keyword">double</span> 变量名<span class="hljs-number">2</span> = 变量名<span class="hljs-number">1</span>.nextDouble()
<span class="hljs-keyword">boolean</span> 变量名<span class="hljs-number">2</span> = 变量名<span class="hljs-number">1</span>.nextBoolean()
</div></code></pre>
<p>实例：生成[-100,100]的数</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Random randomNum = <span class="hljs-keyword">new</span> Random();
        <span class="hljs-keyword">int</span> randomNumNest = (randomNum.nextInt(<span class="hljs-number">201</span>) - <span class="hljs-number">100</span>);
        System.out.println(randomNumNest);
    }
}
</div></code></pre>
<h3 id="string%E7%B1%BB%E7%9A%84%E7%BB%83%E4%B9%A0">String类的练习</h3>
<p>字符串的逆序</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        String str = <span class="hljs-string">"yinghuolight"</span>;
        String newStr = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = str.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            newStr += str.charAt(i);
        }
        System.out.println(newStr);
    }
}
</div></code></pre>
<p>输入字符串后，再输入一个字符，检测这个字符在字符串中出现的次数</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        String str1 = scan.nextLine();
        String str2 = scan.nextLine();
        <span class="hljs-keyword">char</span> str3 = str2.charAt(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str1.length() - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">char</span> ch1 = str1.charAt(i);
            <span class="hljs-keyword">if</span> (ch1 == str3) {
                count++;
            }
        }

        System.out.println(count);
        scan.close();
    }
}
</div></code></pre>
<p>字符串的左旋</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">leftMove</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        String str = <span class="hljs-string">"ABCDEF"</span>;
        <span class="hljs-keyword">int</span> len = <span class="hljs-number">2</span>;
        leftMove test = <span class="hljs-keyword">new</span> leftMove();
        test.leftMove(str, len);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftMove</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> len)</span> </span>{
        String str1 = <span class="hljs-string">""</span>;
        String str2 = <span class="hljs-string">""</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) {
            <span class="hljs-keyword">if</span> (i &lt; len) {
                str1 += str.charAt(i);
            } <span class="hljs-keyword">else</span> {
                str2 += str.charAt(i);
            }
        }

        System.out.println(str2 + str1);

    }

}
</div></code></pre>
<hr>
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6">第二章 流程控制</h2>
<p>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块<br>
程序设计中规定了三种流程结构</p>
<ul>
<li>顺序结构<br>
从上往下逐个执行，中间没有判断和条状</li>
<li>分支结构<br>
选择性执行某段语句</li>
<li>循环语句<br>
循环执行某段代码</li>
</ul>
<h3 id="%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5">分支语句</h3>
<p><strong>关键词：if,else,else if,switch</strong></p>
<pre class="hljs"><code><div>        <span class="hljs-keyword">if</span> (条件表达式) {
            代码块;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式) {
            代码块;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式) {
            代码块;
        } <span class="hljs-keyword">else</span> {
            代码块;
        }
</div></code></pre>
<p><strong>else if</strong>通常在需要多分支时使用<br>
除了<strong>if</strong>可以独立外，其他语句都无法脱离<strong>if</strong>使用</p>
<h4 id="ifelseelse-if%E7%9A%84%E4%BD%BF%E7%94%A8">if，else，else if的使用</h4>
<p>if，else if存在着判断条件，如果判断条件成立，执行这一段代码块，其他则是不执行，起到分支的作用</p>
<p>如果if语句条件成立，那么else if和else都不执行<br>
如果if不成立，else if成立，执行else if，其他不执行<br>
如果if和多个else if都不成立，执行else<br>
实际例子：<br>
成年人心率的正常范围是每分钟60-100次，体检时<br>
如果心率不在此范围内，则需要进一步检查</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        i = scan.nextInt();
        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">60</span> &amp;&amp; i &lt;= <span class="hljs-number">100</span>) {
            System.out.println(<span class="hljs-string">"情况正常"</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">30</span> || i &gt; <span class="hljs-number">130</span>) {
            System.out.println(<span class="hljs-string">"？您？"</span>);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"莫得惊艳点"</span>);
        }
    }
}
</div></code></pre>
<p>上述代码中，if-else结构需要执行的语句就一句，你可以省略大括号</p>
<pre class="hljs"><code><div>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">60</span> &amp;&amp; i &lt;= <span class="hljs-number">100</span>)
            System.out.println(<span class="hljs-string">"情况正常"</span>);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">30</span> || i &gt; <span class="hljs-number">130</span>)
            System.out.println(<span class="hljs-string">"？您？"</span>);
        <span class="hljs-keyword">else</span>
            System.out.println(<span class="hljs-string">"莫得惊艳点"</span>);
</div></code></pre>
<p>我个人建议是加上大括号，除非你这个结构是绝对不会进行更改<br>
并且只是简单的逻辑判定，没有用在很复杂的结构<br>
if-else的匹配是就近原则，只有在使用大括号时才允许忽略就近原则<br>
就近原则就是else默认匹配最近的if</p>
<p>在多分支选择中 有可能会出现中间值<br>
按照日常使用 我们会下意识使用<br>
d &lt;= xx &lt; k<br>
这种表达是不得当的<br>
为什么？<br>
&lt;=和&lt;都是二元操作符，也就是只能两个间运算<br>
d &lt;= xx已经进行了运算，返回了一个boolean值用来表示是与否<br>
这时候表达式就变成boolean &lt; k，Java不允许boolean值与整型运算<br>
正确表达应该是<br>
xx &gt;= d &amp;&amp; xx &lt; k  //&amp;&amp; 并<br>
然后就是建议条件尽可能写成<strong>左闭右开</strong>的形式<br>
能写成x &lt; 10就不要写成x &lt;= 9<br>
（与C语言不同，C语言是返回常量）</p>
<h5 id="%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8">嵌套使用</h5>
<p>首先要牢记的前提是<br>
除了<strong>if</strong>可以独立外，其他语句都无法脱离<strong>if</strong>使用<br>
在这里前提下，你可以任意加入if-else结构<br>
可以在if中加入if，也可以在else if和else中加入if</p>
<p>来做道题<br>
输入三个整数，给他们排序</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> num2 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> num3 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        num1 = scan.nextInt();
        num2 = scan.nextInt();
        num3 = scan.nextInt();
        <span class="hljs-keyword">if</span> (num1 &lt; num2) {
            tmp = num1;
            num1 = num2;
            num2 = tmp;
        }
        <span class="hljs-keyword">if</span> (num1 &lt; num3) {
            tmp = num1;
            num1 = num3;
            num3 = tmp;
        }
        <span class="hljs-keyword">if</span> (num2 &lt; num3) {
            tmp = num2;
            num2 = num3;
            num3 = tmp;
        }
        System.out.println(<span class="hljs-string">"num1="</span> + num1 + <span class="hljs-string">" num2="</span> + num2 + <span class="hljs-string">" num3="</span> + num3);
    }
}
</div></code></pre>
<p>这里我不打算使用嵌套，这道题嵌套写起来其实是比较麻烦的<br>
我选择更有简洁性的多if语句，尽管效率未必有if-else高<br>
在实际开发中，是不会出现超过三层的if-else结构，如果超过了，建议对代码进行更改</p>
<h4 id="switch-case%E7%BB%93%E6%9E%84">switch-case结构</h4>
<pre class="hljs"><code><div>        <span class="hljs-keyword">switch</span> (表达式) {
            <span class="hljs-comment">//表达式只能是char，byte，short，int，String，枚举</span>
            <span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:
                代码块;
            <span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:
            <span class="hljs-keyword">case</span> 常量<span class="hljs-number">3</span>:
                代码块<span class="hljs-number">2</span>;
            <span class="hljs-keyword">default</span>:
                代码块;
            <span class="hljs-comment">//default是默认，当输入switch的值均不符合分支时</span>
            <span class="hljs-comment">//可以设定default分支来回应</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> input = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        input = scan.nextInt();
        <span class="hljs-keyword">switch</span> (input) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                System.out.println(<span class="hljs-string">"第一个分支结果"</span>);
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                System.out.println(<span class="hljs-string">"第二个分支结果"</span>);
            <span class="hljs-keyword">default</span>:
                System.out.println(<span class="hljs-string">"其他结果"</span>);
        }
    }
}
</div></code></pre>
<p>上述就是一个switch-case结构的简单例子，如果你有运行过<br>
你会发现输出结果是全部分支而不是想要的分支结果<br>
这个时候需要用到<strong>break</strong><br>
鉴于我switch结构用得少，我不知道什么情况需要输出多个分支</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> input = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        input = scan.nextInt();
        <span class="hljs-keyword">switch</span> (input) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                System.out.println(<span class="hljs-string">"第一个分支结果"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                System.out.println(<span class="hljs-string">"第二个分支结果"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                System.out.println(<span class="hljs-string">"其他结果"</span>);
                <span class="hljs-keyword">break</span>;
        }
    }
}
</div></code></pre>
<p><strong>break</strong>可以终止switch语句，<strong>case</strong>相当于switch的入口，决定switch从哪里开始<br>
而<strong>break</strong>则是出口，决定从哪里跳出switch，<strong>break</strong>语句并不是必要的<br>
你可以不添加<strong>break</strong>以此来输出多个分支结果<br>
同样，在switch中可以使用<strong>contiue</strong>，用来跳过后续的代码，直接进入判断部分<br>
switch语句的效率是比if-self要高的，可以选择性使用</p>
<h5 id="switch%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0">switch综合练习</h5>
<p>不允许使用if-self结构，使用switch结构来实现以下功能</p>
<ol>
<li>允许自由输入数据</li>
<li>若数据大于60，打印达标，若低于60，打印不合格</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-comment">//方法1</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> input = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        input = scan.nextInt();
        scan.close();
        <span class="hljs-keyword">switch</span> (input / <span class="hljs-number">10</span>) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
                System.out.println(<span class="hljs-string">"不合格"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:
                System.out.println(<span class="hljs-string">"达标"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                System.out.println(<span class="hljs-string">"成绩出错"</span>);
        }
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> input = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        input = scan.nextInt();
        scan.close();
        <span class="hljs-keyword">switch</span> (input / <span class="hljs-number">60</span>) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                System.out.println(<span class="hljs-string">"不合格"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                System.out.println(<span class="hljs-string">"达标"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                System.out.println(<span class="hljs-string">"成绩出错"</span>);
        }
    }
}
</div></code></pre>
<h3 id="%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">循环语句</h3>
<p>关键词：for，while，do...while<br>
循环结构有三种：</p>
<ol>
<li>for循环</li>
<li>while循环</li>
<li>do while循环</li>
</ol>
<h4 id="for%E5%BE%AA%E7%8E%AF">for循环</h4>
<pre class="hljs"><code><div>        <span class="hljs-keyword">for</span> (初始部分; 判断条件; 调整部分) {
            代码块;
        }
</div></code></pre>
<p>初始部分：相当于初始化条件<br>
判断条件：循环进行的条件<br>
调整部分：每次循环进行什么调整<br>
你可以通过下面的例子快速理解：<br>
（使用了数组内容知识）</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span>[] arr = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>};
        <span class="hljs-comment">//或者int[] arr = new int[10];</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            System.out.print(arr[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<p>for循环进行流程是这样的<br>
初始部分-&gt;判断条件-&gt;满足条件-&gt;调整部分-&gt;判断条件-&gt;满足条件-&gt;调整部分-&gt;判断条件-&gt;不满足条件-&gt;不进入循环</p>
<p>值得一提，for循环三个条件可有可无<br>
你可以省略初始化部分，也能省略判断条件，三个都省略也是能运行的<br>
知道就行，实战还是别乱拿来耍</p>
<h4 id="while%E5%BE%AA%E7%8E%AF">while循环</h4>
<pre class="hljs"><code><div>        初始部分;
        <span class="hljs-keyword">while</span> (循环条件) {
            代码块;
            调整部分;
        }
</div></code></pre>
<p>在循环结构中，也可以使用<strong>break</strong>语句<br>
可以用来跳出循环<br>
除了<strong>break</strong>语句外，还有<strong>continue</strong>语句<br>
与<strong>break</strong>语句不同，<strong>break</strong>是永久终止循环<br>
而<strong>continue</strong>是跳过自身后面的代码，直接进入判断部分</p>
<p>来做道题<br>
输出1-100间所有偶数的和，同时输出偶数个数</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//你可以在初始部分直接定义</span>
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                sum += i;
                count++;
            }
        }
        System.out.println(<span class="hljs-string">"偶数之和为"</span> + sum + <span class="hljs-string">" 偶数个数为"</span> + count);
    }
}
</div></code></pre>
<h5 id="%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0">循环结构综合练习</h5>
<p>1.输出所有水仙花数，水仙花数是一个三位数，其各个位上数字立方和等于其本身</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
            <span class="hljs-keyword">if</span> (i == (i / <span class="hljs-number">100</span>) * (i / <span class="hljs-number">100</span>) * (i / <span class="hljs-number">100</span>)
                    + ((i / <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>) * ((i / <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>) * ((i / <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>)
                    + (i % <span class="hljs-number">10</span>) * (i % <span class="hljs-number">10</span>) * (i % <span class="hljs-number">10</span>)) {
                System.out.print(i + <span class="hljs-string">" "</span>);
            }
        }
    }
}
</div></code></pre>
<p>我个人建议创建三个变量来做这道题，就不要像我这样做</p>
<p>2.输入两个正整数，求最大公约数和最小公倍数<br>
最大公约数</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-comment">//方法1</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        m = scan.nextInt();
        n = scan.nextInt();
        <span class="hljs-keyword">int</span> min = (m &lt; n) ? m : n;
        scan.close();

        <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= min; i++) {
            <span class="hljs-keyword">if</span> (m % i == <span class="hljs-number">0</span> &amp;&amp; n % i == <span class="hljs-number">0</span>) {
                result = i;
            }
        }
        System.out.println(result);
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-comment">//方法2</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        m = scan.nextInt();
        n = scan.nextInt();
        <span class="hljs-keyword">int</span> min = (m &lt; n) ? m : n;
        scan.close();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = min; i &gt; <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">if</span> (m % i == <span class="hljs-number">0</span> &amp;&amp; n % i == <span class="hljs-number">0</span>) {
                System.out.println(i);
                <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-comment">//while循环做法</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        m = scan.nextInt();
        n = scan.nextInt();
        scan.close();

        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)
        {
            System.out.println(m);
        }

        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">int</span> invoke = n;
            n = m % n;
            m = invoke;
        }
        System.out.println(m);
    }
}
</div></code></pre>
<p>其实这三个例子都只是实现了功能，并没有进行一定的处理<br>
例如两个数都为0，或者任一为0的情况，感兴趣自己去想想怎么优化</p>
<p>最小公倍数（不考虑0的情况，因为懒）</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        m = scan.nextInt();
        n = scan.nextInt();
        scan.close();
        <span class="hljs-keyword">int</span> ret = m * n;

        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {
            System.out.println(m);
        }

        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">int</span> invoke = n;
            n = m % n;
            m = invoke;
        }
        System.out.println(<span class="hljs-string">"最大公约数为"</span> + m);
        System.out.println(<span class="hljs-string">"最小公倍数为"</span> + ret / m);
    }
}
</div></code></pre>
<p>3.猜数字游戏</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> input = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> randomNum = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">101</span>);
        System.out.println(<span class="hljs-string">"猜猜数字&gt;[0,100]"</span>);
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            System.out.print(<span class="hljs-string">"请输入一个数字&gt;"</span>);
            input = scan.nextInt();

            <span class="hljs-keyword">if</span> (input == randomNum) {
                System.out.println(<span class="hljs-string">"猜对了"</span>);
                <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">if</span> (input &gt; randomNum) {
                System.out.println(<span class="hljs-string">"猜大了"</span>);
            }

            <span class="hljs-keyword">if</span> (input &lt; randomNum) {
                System.out.println(<span class="hljs-string">"猜小了"</span>);
            }

        }
        scan.close();
    }
}
</div></code></pre>
<p>如果你想要更高的效率，你要改用if-else结构<br>
多if语句效率是没有if-self结构高的</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> input = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> randomNum = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">101</span>);
        System.out.println(<span class="hljs-string">"猜猜数字&gt;[0,100]"</span>);
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            System.out.print(<span class="hljs-string">"请输入一个数字&gt;"</span>);
            input = scan.nextInt();

            <span class="hljs-keyword">if</span> (input &gt; randomNum) {
                System.out.println(<span class="hljs-string">"猜大了"</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input &lt; randomNum) {
                System.out.println(<span class="hljs-string">"猜小了"</span>);
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"猜对了"</span>);
                <span class="hljs-keyword">break</span>;
            }
        }
        scan.close();
    }
}
</div></code></pre>
<h4 id="dowhile%E5%BE%AA%E7%8E%AF">do...while循环</h4>
<pre class="hljs"><code><div>        初始部分
        <span class="hljs-keyword">do</span> {
            代码块;
            调整部分;
        } <span class="hljs-keyword">while</span> (循环条件);
</div></code></pre>
<p>do...while循环执行过程：<br>
初始部分-&gt;调整部分-&gt;循环条件-&gt;满足条件-&gt;调整部分-&gt;循环条件-&gt;不满足条件-&gt;不进入循环<br>
do...while循环就是先进行一次再循环</p>
<p>使用do...while结构做一个简单的ATM</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> input = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">double</span> money = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">double</span> hasMoney = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">double</span> carryMoney = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        System.out.print(<span class="hljs-string">"请设定你所有的金额&gt;"</span>);
        hasMoney = scan.nextDouble();
        System.out.println(<span class="hljs-string">"设定成功，你现在拥有"</span> + hasMoney + <span class="hljs-string">"金额\n"</span>);
        <span class="hljs-keyword">do</span> {
            System.out.println(<span class="hljs-string">"1.存款"</span>);
            System.out.println(<span class="hljs-string">"2.取款"</span>);
            System.out.println(<span class="hljs-string">"3.显示余额"</span>);
            System.out.println(<span class="hljs-string">"0.退出"</span>);
            System.out.print(<span class="hljs-string">"请选择&gt;"</span>);
            input = scan.nextInt();

            <span class="hljs-keyword">switch</span> (input) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                    System.out.print(<span class="hljs-string">"存入多少金额&gt;"</span>);
                    money = scan.nextDouble();
                    <span class="hljs-keyword">if</span> (money &gt; hasMoney) {
                        System.out.println(<span class="hljs-string">"余额不够\n"</span>);
                    } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">//else if (money &lt;= hasMoney)</span>
                        hasMoney -= money;
                        System.out.println(<span class="hljs-string">"存入成功，你现在账户余额为"</span> + money);
                        System.out.println(<span class="hljs-string">"你现在持有"</span> + hasMoney + <span class="hljs-string">"金额\n"</span>);
                    }
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                    System.out.println(<span class="hljs-string">"账户余额为"</span> + money);
                    System.out.print(<span class="hljs-string">"取出多少金额&gt;"</span>);
                    carryMoney = scan.nextDouble();
                    <span class="hljs-keyword">if</span> (carryMoney &gt; money) {
                        System.out.println(<span class="hljs-string">"账户余额不够\n"</span>);
                    } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">//else if (carryMoney &lt;= money)</span>
                        money -= carryMoney;
                        hasMoney = hasMoney + carryMoney;
                        System.out.println(<span class="hljs-string">"取出成功，你现在账户余额为"</span> + money);
                        System.out.println(<span class="hljs-string">"你现在持有"</span> + hasMoney + <span class="hljs-string">"金额\n"</span>);
                    }
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                    System.out.println(<span class="hljs-string">"账户余额为"</span> + money + <span class="hljs-string">"\n"</span>);
                    <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    System.out.println(<span class="hljs-string">"已退出ATM机"</span>);
                    <span class="hljs-keyword">break</span>;
            }

        } <span class="hljs-keyword">while</span> (input != <span class="hljs-number">0</span>);
        scan.close();
    }
}
</div></code></pre>
<p>这里留了一个扩展点，我留下了else if分支，你可以利用else分支去实现一些缺少的功能，如，检测输入是否正确</p>
<h4 id="%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF">“无限”循环</h4>
<p>典型的无限循环结构有<code>while(true)</code>和<code>for(;;)</code><br>
“无限”循环常用于不知道循环多少次，依靠循环内部的条件来结束的场景</p>
<h4 id="%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%BB%83%E4%B9%A0">循环的练习</h4>
<p>使用嵌套循环输出棱形</p>
<pre class="hljs"><code><div>    *
   ***
  *****
 *******
*********
 *******
  *****
   ***
    *
</div></code></pre>
<p>输出一个这样的棱形</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> line = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        line = scan.nextInt();
        scan.close();  <span class="hljs-comment">//我认为没有必要再使用Scanner</span>

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; line; i++) {
            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; line - <span class="hljs-number">1</span> - i; j++) {
                System.out.print(<span class="hljs-string">" "</span>);
            }

            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; j++) {
                System.out.print(<span class="hljs-string">"*"</span>);
            }

            System.out.println();
        }

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; line - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= i; j++) {
                System.out.print(<span class="hljs-string">" "</span>);
            }

            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * (line - <span class="hljs-number">1</span> - i) - <span class="hljs-number">1</span>; j++) {
                System.out.print(<span class="hljs-string">"*"</span>);
            }

            System.out.println();
        }
    }
}
</div></code></pre>
<p>打印9*9乘法表</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {
                System.out.print(i + <span class="hljs-string">" * "</span> + j + <span class="hljs-string">" = "</span> + i * j + <span class="hljs-string">"  "</span>);
            }

            System.out.print(<span class="hljs-string">"\n"</span>);
        }
    }
}
</div></code></pre>
<p>打印素数</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        num = scan.nextInt();
        scan.close();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= num; i++) {

            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span>; j &lt; i; j++) {
                <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) {
                    flag = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (flag) {
                System.out.print(i + <span class="hljs-string">" "</span>);
            }
        }
    }
}
</div></code></pre>
<h2 id="%E6%97%B6%E9%97%B4%E9%94%A5%E7%9A%84%E5%BA%94%E7%94%A8">时间锥的应用</h2>
<p>如何知道代码运行的时间呢？<br>
可以借助时间锥<a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/System.html#currentTimeMillis()">currentTimeMillis</a>，时间锥的单位是毫秒</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.currentTimeMillis;

<span class="hljs-keyword">long</span> 变量名<span class="hljs-number">1</span> = currentTimeMillis()

<span class="hljs-keyword">long</span> 变量名<span class="hljs-number">2</span> = currentTimeMillis()
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.currentTimeMillis;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">long</span> start = currentTimeMillis();

        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        num = scan.nextInt();
        scan.close();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= num; i++) {

            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span>; j &lt; i; j++) {
                <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) {
                    flag = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (flag) {
                System.out.print(i + <span class="hljs-string">" "</span>);
            }
        }

        <span class="hljs-keyword">long</span> end = currentTimeMillis();
        System.out.println(end-start);
    }
}
</div></code></pre>
<p>获取代码的运算时间是为了优化算法，寻求更高的运行效率，下面是改进了算法的求质数代码，你可以自行比较一下它们的运行时间</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;
<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.System.currentTimeMillis;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">long</span> start = currentTimeMillis();

        <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        num = scan.nextInt();
        scan.close();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= num; i++) {

            <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span>; j &lt;= Math.sqrt(i); j++) {
                <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) {
                    flag = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (flag) {
                System.out.print(i + <span class="hljs-string">" "</span>);
            }
        }

        <span class="hljs-keyword">long</span> end = currentTimeMillis();
        System.out.println(end - start);
    }
}
</div></code></pre>
<p>初步实战-谷粒记账软件<br>
GuLiAccount.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuLiAccount</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> hasMoney = <span class="hljs-number">10000</span>;
        <span class="hljs-keyword">boolean</span> isFlag = <span class="hljs-keyword">true</span>;
        String info = <span class="hljs-string">""</span>;
        <span class="hljs-keyword">do</span> {
            System.out.println(<span class="hljs-string">"\n-----------------谷粒记账软件-----------------\n"</span>);
            System.out.println(<span class="hljs-string">"                 1 收支明细"</span>);
            System.out.println(<span class="hljs-string">"                 2 登记收入"</span>);
            System.out.println(<span class="hljs-string">"                 3 登记支出"</span>);
            System.out.println(<span class="hljs-string">"                 4 退   出\n"</span>);
            System.out.print(<span class="hljs-string">"                 请选择&gt;"</span>);

            <span class="hljs-keyword">char</span> selection = Utility.readMenuSelection();
            <span class="hljs-keyword">switch</span> (selection) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">'1'</span>:
                    System.out.println(<span class="hljs-string">"------------------收支明细-------------------"</span>);
                    System.out.println(<span class="hljs-string">"收支\t\t账户金额\t\t收支金额\t\t说明"</span>);
                    System.out.println(info);
                    System.out.println(<span class="hljs-string">"-------------------------------------------"</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'2'</span>:
                    System.out.print(<span class="hljs-string">"本次收入金额&gt;"</span>);
                    <span class="hljs-keyword">int</span> money1 = Utility.readNumber();

                    <span class="hljs-keyword">if</span> (money1 &gt; <span class="hljs-number">0</span>) {
                        hasMoney += money1;
                    }

                    System.out.print(<span class="hljs-string">"本次收入说明&gt;"</span>);
                    String addDesc = Utility.readString();
                    info += <span class="hljs-string">"收入\t\t"</span> + hasMoney + <span class="hljs-string">"\t\t"</span> + money1 + <span class="hljs-string">"\t\t    "</span> + addDesc + <span class="hljs-string">"\n"</span>;
                    System.out.println(<span class="hljs-string">"------------------登记完成-------------------"</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'3'</span>:
                    System.out.print(<span class="hljs-string">"本次支出金额&gt;"</span>);
                    <span class="hljs-keyword">int</span> money2 = Utility.readNumber();

                    <span class="hljs-keyword">if</span> (money2 &gt; <span class="hljs-number">0</span> &amp;&amp; hasMoney &gt; money2) {
                        hasMoney -= money2;
                    }

                    System.out.print(<span class="hljs-string">"本次支出说明&gt;"</span>);
                    String minusDesc = Utility.readString();
                    info += <span class="hljs-string">"支出\t\t"</span> + hasMoney + <span class="hljs-string">"\t\t"</span> + money2 + <span class="hljs-string">"\t\t    "</span> + minusDesc + <span class="hljs-string">"\n"</span>;
                    System.out.println(<span class="hljs-string">"------------------登记完成-------------------"</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">'4'</span>:
                    System.out.print(<span class="hljs-string">"是否退出(Y/N)&gt;"</span>);
                    <span class="hljs-keyword">char</span> isExit = Utility.readConfirmSelection();
                    <span class="hljs-keyword">if</span> (isExit == <span class="hljs-string">'Y'</span>) {
                        isFlag = <span class="hljs-keyword">false</span>;
                    }
                    <span class="hljs-keyword">break</span>;
            }
        } <span class="hljs-keyword">while</span> (isFlag);
    }
}
</div></code></pre>
<p>Utility.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utility</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-title">readMenuSelection</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">char</span> c;
        <span class="hljs-keyword">for</span> (; ; ) {
            String str = readKeyBoard(<span class="hljs-number">1</span>);
            c = str.charAt(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (c != <span class="hljs-string">'1'</span> &amp;&amp; c != <span class="hljs-string">'2'</span> &amp;&amp; c != <span class="hljs-string">'3'</span> &amp;&amp; c != <span class="hljs-string">'4'</span>) {
                System.out.print(<span class="hljs-string">"选择错误，请重新输入&gt;"</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">return</span> c;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">readNumber</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> n;
        <span class="hljs-keyword">for</span> (; ; ) {
            String str = readKeyBoard(<span class="hljs-number">4</span>);
            <span class="hljs-keyword">try</span> {
                n = Integer.parseInt(str);
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">catch</span> (NumberFormatException e) {
                System.out.print(<span class="hljs-string">"数字输入错误，请重新输入&gt;"</span>);
            }
        }
        <span class="hljs-keyword">return</span> n;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">readString</span><span class="hljs-params">()</span> </span>{
        String str = readKeyBoard(<span class="hljs-number">8</span>);
        <span class="hljs-keyword">return</span> str;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> <span class="hljs-title">readConfirmSelection</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">char</span> c;
        <span class="hljs-keyword">for</span> (; ; ) {
            String str = readKeyBoard(<span class="hljs-number">1</span>).toUpperCase();
            c = str.charAt(<span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">'Y'</span> || c == <span class="hljs-string">'N'</span>) {
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> {
                System.out.print(<span class="hljs-string">"选择错误，请重新输入&gt;"</span>);
            }
        }
        <span class="hljs-keyword">return</span> c;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">readKeyBoard</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span> </span>{
        String line = <span class="hljs-string">""</span>;

        <span class="hljs-keyword">while</span> (scan.hasNext()) {
            line = scan.nextLine();
            <span class="hljs-keyword">if</span> (line.length() &lt; <span class="hljs-number">1</span> || line.length() &gt; limit) {
                System.out.print(<span class="hljs-string">"输入错误，请重新输入&gt;"</span>);
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">return</span> line;
    }
}
</div></code></pre>
<p>你可以对其进行改造，这一次我就不作示范了<br>
给大家自由实践的机会</p>
<h2 id="%E6%95%B0%E7%BB%84">数组</h2>
<p>数组是多个相同类型数据按照一定顺序排序的集合<br>
并用一个名字命名，并通过编号的方式对这些数据进行统一的管理<br>
数组的初始化有多种形式</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>[] a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>};
<span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};

<span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];
<span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];
</div></code></pre>
<p>数组中有着几个概念，分别是数组名，元素，下标，长度<br>
拿int[] a = new int[]{1, 2, 3, 4, 5};进行举例<br>
a是数组名，1，2，3，4，5是元素<br>
a[0]代表的就是元素1，a[0]相当于数组第一位，[0]是下标<br>
长度就是数组的容量，多少个元素就是多长，想要打印长度可以使用<code>System.out.println(a.length)</code></p>
<p>数组自身的特性说明了数组在内存中是连续存放的，因而各个元素之间相差的地址大小总是相等的</p>
<p>数组它是一组数据，常规的打印显然是不适合<br>
我们需要使用循环来打印所有的元素</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) {
            System.out.println(a[i]);
        }
    }
}
</div></code></pre>
<p>上述都是进行了初始化，如果不进行初始化，会得出什么结果？<br>
数组的默认初始化值是多少呢？</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">double</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">char</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">4</span>];
        String[] d = <span class="hljs-keyword">new</span> String[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">boolean</span>[] e = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">4</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) {
            System.out.print(a[i] + <span class="hljs-string">" "</span>);
            System.out.print(b[i] + <span class="hljs-string">" "</span>);
            System.out.print(c[i] + <span class="hljs-string">" "</span>);
            System.out.print(d[i] + <span class="hljs-string">" "</span>);
            System.out.print(e[i] + <span class="hljs-string">"\n"</span>);
        }
    }
}
</div></code></pre>
<p>说结论，整型和浮点型默认值都是0，字符型是空字符，String类是null，布尔类型是false</p>
<h3 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90">一维数组的内存解析</h3>
<p>tmd，指针还在追我<br>
Java将内存划分为五块，程序计数器，虚拟机栈，本地方法栈，堆，方法区</p>
<p>目前与数组相关的内存结构是虚拟机栈和堆<br>
虚拟机栈：用于存放方法的局部变量，包括基本数据类型的变量和引用数据类型的变量，以及某些对象的引子，好比如说数组名<br>
堆：所有的对象实例和数组都是在堆中分配内存的，当一个对象被创建时，它的引用可以存放在虚拟机栈的局部变量中，但对象本身是在堆中分配的</p>
<p>虚拟机栈以栈帧为基本单位，有入栈和出栈的操作，一个栈帧相当于一个方法，方法中的局部变量存放于栈帧中</p>
<p>如果有人学过C语言或C++，或者学过数据结构，那么基本听说过栈<br>
栈区的存放特点是先进后出，好比如说</p>
<pre class="hljs"><code><div>[]  （第一个取出）  
[]  
[]  
[]  
[]  
[]  
[]  
[]  
[]  
[]  
[]  
[]  （第一个存放）  
</div></code></pre>
<p>我们以两个例子来说明</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];
arr1[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;
arr1[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span>;

String[] arr2 = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];
arr2[<span class="hljs-number">1</span>] = <span class="hljs-string">"荧火光"</span>;
</div></code></pre>
<p>上面说过栈区是存放变量的，也就是数组名</p>
<pre class="hljs"><code><div>[]  （第一个取出）  
[]  
[]  
[]  
[]  
[]  
[]  
[]  
[]  
[]  
[arr2：<span class="hljs-number">0xaabb</span>]  
[arr1：<span class="hljs-number">0x12ab</span>]  （第一个存放）  
</div></code></pre>
<p>栈区存放的数组名，其实本质是存放地址的首元素地址<br>
我们所创建的变量，方法，在栈区中都是以地址的形式存在<br>
数组的连续性存放使得我们能够凭借首元素地址便可以直接访问所有元素</p>
<p>同时，我们知道，数据在内存中的存储方式是补码，这就意味着我们需要将内容进行转换<br>
像String这种字符串，同样需要被转换，不同的是，它们还需要放进常量池中<br>
在Java中，字符串都要被存放进常量池，这些字符串被认为成常量<br>
当有变量指向相同的字符串时，它们本质上都指向了这个字符串的地址，没有再一次开辟新的空间<br>
然而，仅仅只有字符串是这样的，数据常量依旧需要开辟空间<br>
暂且知道这些就足够了，后续面向对象会深入了解</p>
<h4 id="%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84">两个变量指向一个数组</h4>
<p>先来看一段代码</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];
        arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;
        arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;
        arr[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;

        System.out.println(arr[<span class="hljs-number">0</span>]);
        System.out.println(arr[<span class="hljs-number">1</span>]);
        System.out.println(arr[<span class="hljs-number">2</span>]);
        System.out.println();

        <span class="hljs-keyword">int</span>[] arr1 = arr;  <span class="hljs-comment">//将arr的地址赋给了arr1</span>
        arr1[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span>;
        System.out.println(arr[<span class="hljs-number">0</span>]);
        System.out.println(arr[<span class="hljs-number">1</span>]);
        System.out.println(arr[<span class="hljs-number">2</span>]);
    }
}
</div></code></pre>
<p>上述代码中，实现了类似C/C++语言中的指针操作，将数组arr的地址赋给了arr1，这两个变量指向了同一个地址，对arr1操作，相当于操作arr，这个操作不需要开辟新的内存空间</p>
<h3 id="%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0">一维数组练习</h3>
<ol>
<li>翻译手机号码</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = {<span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>};
        <span class="hljs-keyword">int</span>[] index = {<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>};  <span class="hljs-comment">//11</span>
        String tel = <span class="hljs-string">""</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; index.length; i++) {
            <span class="hljs-keyword">int</span> value = index[i];
            tel += arr[value];
            <span class="hljs-comment">//1 8 0 1 3 8 2 0 1 0 0</span>
        }

        System.out.println(<span class="hljs-string">"联系方式 "</span> + tel);
    }
}
</div></code></pre>
<ol start="2">
<li>输入1-7，打印星期X</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> input = <span class="hljs-number">0</span>;
        String[] arr = {<span class="hljs-string">"星期一"</span>, <span class="hljs-string">"星期二"</span>, <span class="hljs-string">"星期三"</span>, <span class="hljs-string">"星期四"</span>, <span class="hljs-string">"星期五"</span>, <span class="hljs-string">"星期六"</span>, <span class="hljs-string">"星期日"</span>};
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);

        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            input = scan.nextInt();
            <span class="hljs-keyword">if</span> (input &gt;= <span class="hljs-number">1</span> &amp;&amp; input &lt;= <span class="hljs-number">7</span>) {
                System.out.println(arr[input - <span class="hljs-number">1</span>]);
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"输入错误，请重新输入"</span>);
            }
        }
        scan.close();
    }
}
<span class="hljs-comment">//这里做了简单的判断，要处理除整型外的是有一些复杂的，平时练习没有那个必要</span>
</div></code></pre>
<ol start="3">
<li>输入学生人数以及成绩，找出最高分，并进行等级划分，等级依据最高分来取（例如，最高分-10，最高分-20等）</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        System.out.print(<span class="hljs-string">"请输入学生人数&gt;"</span>);
        <span class="hljs-keyword">int</span> count = scan.nextInt();
        <span class="hljs-keyword">int</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[count];
        System.out.println(<span class="hljs-string">"请依次输入学生成绩&gt;"</span>);

        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> max = scores[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; scores.length; i++) {
            scores[i] = scan.nextInt();

            <span class="hljs-keyword">if</span> (max &lt; scores[i]) {
                max = scores[i];
            }
        }
        System.out.println(<span class="hljs-string">"最高分&gt;"</span> + max);

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; scores.length; i++) {
            <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">10</span>) {
                System.out.println(<span class="hljs-string">"学生"</span> + i + <span class="hljs-string">" 分数为"</span> + scores[i] + <span class="hljs-string">" 等级A"</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">20</span>) {
                System.out.println(<span class="hljs-string">"学生"</span> + i + <span class="hljs-string">" 分数为"</span> + scores[i] + <span class="hljs-string">" 等级B"</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">30</span>) {
                System.out.println(<span class="hljs-string">"学生"</span> + i + <span class="hljs-string">" 分数为"</span> + scores[i] + <span class="hljs-string">" 等级C"</span>);
            } <span class="hljs-keyword">else</span> {
                System.out.println(<span class="hljs-string">"学生"</span> + i + <span class="hljs-string">" 分数为"</span> + scores[i] + <span class="hljs-string">" 等级D"</span>);
            }
        }
        scan.close();
    }
}
</div></code></pre>
<p>可以去写一个输入学生名的，例如：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;

        System.out.print(<span class="hljs-string">"请输入学生人数&gt;"</span>);
        <span class="hljs-keyword">int</span> count = scan.nextInt();
        scan.nextLine();  <span class="hljs-comment">//清除缓冲区</span>

        String[] nameLine = <span class="hljs-keyword">new</span> String[count];
        System.out.println(<span class="hljs-string">"请依次输入学生名字&gt;"</span>);

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nameLine.length; i++) {
            nameLine[i] = scan.nextLine();
        }

        <span class="hljs-keyword">int</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[count];
        System.out.println(<span class="hljs-string">"请依次输入学生成绩&gt;"</span>);

        <span class="hljs-keyword">int</span> max = scores[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; scores.length; i++) {
            scores[i] = scan.nextInt();

            <span class="hljs-keyword">if</span> (max &lt;= scores[i]) {
                max = scores[i];
            }
        }
        System.out.println(<span class="hljs-string">"最高分&gt;"</span> + max);

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; scores.length; i++) {
            <span class="hljs-keyword">char</span> grade = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">10</span>) {
                grade = <span class="hljs-string">'A'</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">20</span>) {
                grade = <span class="hljs-string">'B'</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">30</span>) {
                grade = <span class="hljs-string">'C'</span>;
            } <span class="hljs-keyword">else</span> {
                grade = <span class="hljs-string">'D'</span>;
            }
            System.out.println(<span class="hljs-string">"学生"</span> + nameLine[i] + <span class="hljs-string">" 分数为"</span> + scores[i] + <span class="hljs-string">" 等级"</span> + grade);
        }
        scan.close();
    }
}
</div></code></pre>
<p>这个是后期的我复习时重写的</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;

        System.out.print(<span class="hljs-string">"请输入学生人数&gt;"</span>);
        <span class="hljs-keyword">int</span> count = scan.nextInt();
        scan.nextLine();
        String[] nameLine = <span class="hljs-keyword">new</span> String[count];
        <span class="hljs-keyword">int</span>[] scores = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[count];

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            System.out.print(<span class="hljs-string">"请输入第"</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">"位"</span> + <span class="hljs-string">"学生的姓名&gt;"</span>);
            nameLine[i] = scan.nextLine();
            System.out.print(<span class="hljs-string">"请输入第"</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">"位"</span> + <span class="hljs-string">"学生的成绩&gt;"</span>);
            scores[i] = scan.nextInt();
            scan.nextLine();
        }

        <span class="hljs-keyword">int</span> max = scores[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; scores.length; i++) {

            <span class="hljs-keyword">if</span> (max &lt;= scores[i]) {
                max = scores[i];
            }
        }
        System.out.println(<span class="hljs-string">"最高分&gt;"</span> + max);

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; scores.length; i++) {
            <span class="hljs-keyword">char</span> grade = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">10</span>) {
                grade = <span class="hljs-string">'A'</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">20</span>) {
                grade = <span class="hljs-string">'B'</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scores[i] &gt;= max - <span class="hljs-number">30</span>) {
                grade = <span class="hljs-string">'C'</span>;
            } <span class="hljs-keyword">else</span> {
                grade = <span class="hljs-string">'D'</span>;
            }
            System.out.println(<span class="hljs-string">"学生"</span> + nameLine[i] + <span class="hljs-string">" 分数为"</span> + scores[i] + <span class="hljs-string">" 等级"</span> + grade);
        }
        scan.close();
    }
}
</div></code></pre>
<h3 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84">二维数组</h3>
<p>二维数组其实是将一维数组作为另一个一维数组的元素，形成的有行列的结构</p>
<h4 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8">二维数组的创建与使用</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>[][] a = {{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>}, {<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>}};
<span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]{{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>}, {<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>}};

<span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];
<span class="hljs-keyword">int</span> a[][] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];

<span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][];  <span class="hljs-comment">//不允许int[][] a = new int[][4]</span>
<span class="hljs-comment">//奇奇怪怪，C语言允许省略行，不允许省略列，这边居然是反过来的</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]{{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>}, {<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>}};
        <span class="hljs-comment">//上面有三个大括号，也就是3行，每个都有4个元素（不够补默认值），也就是a[3][4]</span>
        <span class="hljs-comment">//如何取得元素5？</span>
        System.out.println(a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//第二行，第一列就是元素5</span>
        System.out.println(a[<span class="hljs-number">1</span>]);
        <span class="hljs-comment">//打印的是地址，是这一行的地址，不是首元素地址</span>

        <span class="hljs-comment">//这是将二维数组分成多个一维数组来看</span>
        <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>][];
        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];
        arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

        System.out.println(a.length);  <span class="hljs-comment">//多少行</span>
        System.out.println(a[<span class="hljs-number">0</span>].length);  <span class="hljs-comment">//某一行有多少元素</span>
        System.out.println();

        <span class="hljs-comment">//如何遍历二维数组？</span>
        <span class="hljs-comment">//两个for循环的事情</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; a[i].length; j++) {
                System.out.print(a[i][j] + <span class="hljs-string">" "</span>);
            }
            System.out.println();
        }
    }
}
</div></code></pre>
<p>数组中有关类型提升以及相互赋值等问题</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">byte</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">20</span>];
        arr = arr2;
        <span class="hljs-comment">//是否允许这一种，答案是不允许</span>
        <span class="hljs-comment">//int[]和byte[]是两种不同的引用数据类型</span>
        <span class="hljs-keyword">int</span>[][] arr3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];
        arr = arr3;
        <span class="hljs-comment">//是否允许这一种，答案是不允许</span>
        <span class="hljs-comment">//int[]和int[][]是两种不同的引用数据类型</span>
    }
}
</div></code></pre>
<h4 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%E5%92%8C%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90">二维数组的默认值和内存解析</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//二维数组的默认初始化</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[][] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];
        System.out.println(arr1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//第一行地址</span>
        System.out.println(arr1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//0</span>
        System.out.println();

        <span class="hljs-keyword">int</span>[][] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][];
        System.out.println(arr2[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//null</span>
        System.out.println(arr2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//报错</span>
        System.out.println();

        <span class="hljs-keyword">double</span>[][] doubleArr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];
        System.out.println(doubleArr1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//第一行地址</span>
        System.out.println(doubleArr1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//0.0</span>
        System.out.println();

        <span class="hljs-keyword">double</span>[][] doubleArr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">3</span>][];
        System.out.println(doubleArr2[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//null</span>
        System.out.println(doubleArr2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//报错</span>
        System.out.println();

        <span class="hljs-keyword">char</span>[][] charArr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];
        System.out.println(charArr1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//第一行地址</span>
        System.out.println(charArr1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//0</span>
        System.out.println();

        <span class="hljs-keyword">char</span>[][] charArr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">3</span>][];
        System.out.println(charArr2[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//null</span>
        System.out.println(charArr2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//报错</span>
        System.out.println();

        String[][] stringArr1 = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];
        System.out.println(stringArr1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//第一行地址</span>
        System.out.println(stringArr1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//null</span>
        System.out.println();

        String[][] stringArr2 = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>][];
        System.out.println(stringArr2[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//null</span>
        System.out.println(stringArr2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//报错</span>
        System.out.println();

        <span class="hljs-keyword">boolean</span>[][] booleanArr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];
        System.out.println(booleanArr1[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//第一行地址</span>
        System.out.println(booleanArr1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//false</span>
        System.out.println();

        <span class="hljs-keyword">boolean</span>[][] booleanArr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">3</span>][];
        System.out.println(booleanArr2[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//null</span>
        System.out.println(booleanArr2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]);  <span class="hljs-comment">//报错</span>
        System.out.println();
    }
}
</div></code></pre>
<p>你可以看这个图来理解二维数组的内存解析<br>
<a href="https://imgse.com/i/pAdjjZ8"><img src="https://s21.ax1x.com/2024/10/24/pAdjjZ8.png" alt="pAdjjZ8.png"></a></p>
<h4 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0">二维数组练习</h4>
<ol>
<li>求以下数组所有元素总和<br>
<code>int[][] arr = new int[][]{{3, 5, 8, 0}, {12, 9, 0, 0}, {7, 0, 6, 4}};</code></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]{{<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>}, {<span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>}};
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr[i].length; j++) {
                sum += arr[i][j];
            }
        }
        System.out.println(sum);
    }
}
</div></code></pre>
<h4 id="%E6%95%B0%E7%BB%84-%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%93%8D%E4%BD%9C">数组-常见算法操作</h4>
<ol>
<li>特征值计算<br>
任意定义10个随机（使用random）元素，求出元素的最大值，最小值，总和，平均值</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;

        <span class="hljs-comment">//生成随机并赋值数组</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">int</span> num = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">101</span>);  <span class="hljs-comment">//生成[0,100]的数字</span>
            arr[i] = num;
            System.out.print(arr[i] + <span class="hljs-string">" "</span>);
        }
        System.out.println();

        <span class="hljs-comment">//求最大值，最小值，总和，平均值，不建议实际开发中将所有功能写在一起</span>
        <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">double</span> average = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {

            <span class="hljs-keyword">if</span> (max &lt; arr[i]) {
                max = arr[i];
            }

            <span class="hljs-keyword">if</span> (min &gt; arr[i]) {
                min = arr[i];
            }
            sum += arr[i];
        }
        average = (<span class="hljs-keyword">double</span>) sum / arr.length;
        System.out.println(<span class="hljs-string">"元素最大值&gt;"</span> + max);
        System.out.println(<span class="hljs-string">"元素最小值&gt;"</span> + min);
        System.out.println(<span class="hljs-string">"元素总和&gt;"</span> + sum);
        System.out.println(<span class="hljs-string">"平均值&gt;"</span> + average);
    }
}
</div></code></pre>
<ol start="2">
<li>数组元素赋值<br>
打印杨辉三角<br>
鹏哥的写法</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">int</span> line = scan.nextInt();

        <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[line][line];
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= i; j++) {
                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || i == j) {
                    arr[i][j] = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> {
                    arr[i][j] = arr[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + arr[i - <span class="hljs-number">1</span>][j];
                }
            }
        }

        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; line; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; line - i - <span class="hljs-number">1</span>; k++) {
                System.out.print(<span class="hljs-string">" "</span>);
            }
            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= i; j++) {
                System.out.print(arr[i][j] + <span class="hljs-string">" "</span>);
            }
            System.out.println();
        }
        scan.close();
    }
}
</div></code></pre>
<p>尚硅谷的写法</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[i + <span class="hljs-number">1</span>];
            arr[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
            arr[i][i] = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; arr[i].length - <span class="hljs-number">1</span>; j++) {
                arr[i][j] = arr[i - <span class="hljs-number">1</span>][j] + arr[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
            }
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr[i].length; j++) {
                System.out.print(arr[i][j] + <span class="hljs-string">" "</span>);
            }
            System.out.println();
        }
    }
}
</div></code></pre>
<ol start="3">
<li>数组的赋值与复制<br>
数组的赋值</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) {
            System.out.print(array1[i] + <span class="hljs-string">" "</span>);
        }

        <span class="hljs-keyword">int</span>[] array2 = array1;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                array2[i] = i;
            }
        }

        System.out.println();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) {
            System.out.print(array1[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<p>数组的复制</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) {
            System.out.print(array1[i] + <span class="hljs-string">" "</span>);
        }

        System.out.println();

        <span class="hljs-keyword">int</span>[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[array1.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) {
            array2[i] = array1[i];
            System.out.print(array2[i] + <span class="hljs-string">" "</span>);
        }


        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                array2[i] = i;
            }
        }

        System.out.println();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array1.length; i++) {
            System.out.print(array1[i] + <span class="hljs-string">" "</span>);
        }

        System.out.println();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array2.length; i++) {
            System.out.print(array2[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<ol start="4">
<li>数组元素的反转<br>
鹏哥写法</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">21</span>};
        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span> (left &lt; right) {
            <span class="hljs-keyword">int</span> tmp = arr[left];
            arr[left] = arr[right];
            arr[right] = tmp;
            left++;
            right--;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.print(arr[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<p>尚硅谷写法</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">21</span>};

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length / <span class="hljs-number">2</span>; i++) {
            <span class="hljs-keyword">int</span> tmp = arr[i];
            arr[i] = arr[arr.length - <span class="hljs-number">1</span> - i];
            arr[arr.length - <span class="hljs-number">1</span> - i] = tmp;
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.print(arr[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<p>其他写法（只是见识，不推荐）</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">21</span>};
        <span class="hljs-keyword">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            newArr[arr.length - <span class="hljs-number">1</span> - i] = arr[i];
        }

        arr = newArr;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.print(arr[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<ol start="5">
<li>数组的扩容和缩容<br>
数组的扩容</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
        <span class="hljs-keyword">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span> * arr.length];  <span class="hljs-comment">//arr.length &lt;&lt; 1</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            newArr[i] = arr[i];
        }

        newArr[arr.length] = <span class="hljs-number">10</span>;
        newArr[arr.length + <span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;
        newArr[arr.length + <span class="hljs-number">2</span>] = <span class="hljs-number">30</span>;
        arr = newArr;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.print(arr[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<p>数组的缩容</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
        <span class="hljs-keyword">int</span> deleteIndex = <span class="hljs-number">4</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = deleteIndex; i &lt; arr.length - <span class="hljs-number">1</span>; i++) {
            arr[i] = arr[i + <span class="hljs-number">1</span>];
        }

        arr[arr.length - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.print(arr[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
        <span class="hljs-keyword">int</span> deleteIndex = <span class="hljs-number">4</span>;

        <span class="hljs-keyword">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; deleteIndex; i++) {
            newArr[i] = arr[i];
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = deleteIndex; i &lt; arr.length - <span class="hljs-number">1</span>; i++) {
            newArr[i] = arr[i + <span class="hljs-number">1</span>];
        }

        arr = newArr;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; newArr.length; i++) {
            System.out.print(arr[i] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<ol start="6">
<li>数组的查找，排序<br>
线性查找</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>};
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);
        <span class="hljs-keyword">int</span> searchInt = scan.nextInt();

        <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;
        String output = <span class="hljs-string">"存在数字"</span> + searchInt + <span class="hljs-string">" 索引为&gt;"</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">if</span> (arr[i] == searchInt) {
                <span class="hljs-keyword">if</span> (found) {
                    output += <span class="hljs-string">","</span>;
                }
                output += i;
                found = <span class="hljs-keyword">true</span>;
            }
        }

        <span class="hljs-keyword">if</span> (!found) {
            output = <span class="hljs-string">"不存在数字"</span> + searchInt;
        }

        System.out.print(output);
    }
}
</div></code></pre>
<p>二分查找<br>
二分查找的前提是数据有序</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{-<span class="hljs-number">99</span>, -<span class="hljs-number">54</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">33</span>, <span class="hljs-number">43</span>, <span class="hljs-number">256</span>, <span class="hljs-number">999</span>};
        <span class="hljs-keyword">boolean</span> isFlag = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">256</span>;

        <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> end = arr.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (head &lt;= end) {
            <span class="hljs-keyword">int</span> middle = (head + end) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (arr[middle] == value) {
                System.out.println(<span class="hljs-string">"找到指定的元素，索引为："</span> + middle);
                isFlag = <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">break</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[middle] &gt; value) {
                end = middle - <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                head = middle + <span class="hljs-number">1</span>;
            }
        }

        <span class="hljs-keyword">if</span> (isFlag) {
            System.out.println(<span class="hljs-string">"未找打指定的元素"</span>);
        }
    }
}
</div></code></pre>
<p>后期改写</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{-<span class="hljs-number">99</span>, -<span class="hljs-number">54</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">33</span>, <span class="hljs-number">43</span>, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>, <span class="hljs-number">999</span>};
        <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> end = arr.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">256</span>;
        String output = <span class="hljs-string">"存在数字"</span> + value + <span class="hljs-string">" 索引为&gt;"</span>;
        <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;

        <span class="hljs-keyword">while</span> (head &lt; end) {
            <span class="hljs-keyword">int</span> middle = (head + end) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (arr[middle] == value) {
                <span class="hljs-keyword">if</span> (found) {
                    output += <span class="hljs-string">","</span>;
                }
                output += middle;
                found = <span class="hljs-keyword">true</span>;
                head = middle + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[middle] &gt; value) {
                end = middle - <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                head = middle + <span class="hljs-number">1</span>;
            }
        }

        <span class="hljs-keyword">if</span> (!found) {
            output = <span class="hljs-string">"不存在数字"</span> + value;
        }

        System.out.println(output);
    }
}
</div></code></pre>
<p>冒泡排序</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - i - <span class="hljs-number">1</span>; j++) {
                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {
                    <span class="hljs-keyword">int</span> tmp = arr[j];
                    arr[j] = arr[j + <span class="hljs-number">1</span>];
                    arr[j + <span class="hljs-number">1</span>] = tmp;
                }
            }
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; arr.length; k++) {
            System.out.print(arr[k] + <span class="hljs-string">" "</span>);
        }
    }
}
</div></code></pre>
<p>快速排序<br>
世界十大算法之一，最快的排序算法<br>
具体代码实现不提供<br>
超纲（不是不能写，难写，但是是能写的）</p>
<pre class="hljs"><code><div></div></code></pre>
<h4 id="arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8">Arrays工具类的使用与数组常见的异常</h4>
<p><a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Arrays.html">java.util.Arrays</a>类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法<br>
例如：<br>
比较两个数组是否相等</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};
        <span class="hljs-keyword">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};
        <span class="hljs-keyword">boolean</span> isEquals = Arrays.equals(arr, arr2);
        System.out.println(isEquals);
    }
}
</div></code></pre>
<p>输出数组元素</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};
        System.out.println(Arrays.toString(arr));
    }
}
</div></code></pre>
<p>数组填充</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};
        Arrays.fill(arr, <span class="hljs-number">10</span>);
        System.out.println(Arrays.toString(arr));
    }
}
</div></code></pre>
<p>数组排序</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
</div></code></pre>
<p>二分查找（前提已经进行了排序）</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};
        Arrays.sort(arr);
        <span class="hljs-keyword">int</span> index = Arrays.binarySearch(arr, <span class="hljs-number">5</span>);
        System.out.println(index);
    }
}
</div></code></pre>
<p><strong>相关数组异常</strong></p>
<ol>
<li>数组访问越界</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>};
        System.out.println(arr[arr.length + <span class="hljs-number">1</span>]);  <span class="hljs-comment">//超出范围，不在范围均为越界</span>
        System.out.println(arr[-arr.length]);  <span class="hljs-comment">//超出范围，不在范围均为越界</span>
    }
}
</div></code></pre>
<ol start="2">
<li>空指针异常<br>
情况1</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
        arr = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//某些操作导致元素变为null</span>
        System.out.println(arr[<span class="hljs-number">0</span>]);
    }
}
</div></code></pre>
<p>情况2</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][];
        System.out.println(arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);
    }
}
</div></code></pre>
<p>情况3<br>
null情况下调用方法<br>
面向对象会讲</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        String[] arr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">4</span>];
        System.out.println(arr[<span class="hljs-number">0</span>].toString());
    }
}
</div></code></pre>
<h2 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</h2>
<p>在Java中，类的成员有属性，方法，构造器，代码块，内部类<br>
类是具有相同特征的事物的抽象描述，是抽象的、概念上的定义<br>
对象则是实际存在的该类事物的每个个体，是具体的</p>
<p>简单来说<br>
类是抽象的概念定义<br>
对象则是实实在在存在的事物<br>
通俗化来说，类就是人，包括了人种，皮肤颜色等人类特征，而对象则是白种人，黄种人，黑种人</p>
<p>面向对象，是软件开发中的一类编程风格、开发范式<br>
面向对象的有着封装，继承，多态的特征<br>
面向对象所关注的焦点是类，在计算机程序设计过程中，参照现实中的事物，将事物的属性特征、行为特征抽象出来，用类来表示<br>
类和对象是面向对象的核心<br>
在面向对象中，会使用到一些其他关键词：this，super，package，import，static，final，interface，abstract等</p>
<p>面向过程和面向对象两者是并不冲突的，它们相辅相成<br>
面向过程是以某一件事情的实现为主，面向对象则是实现某一件事情里面的对象会做什么的定义<br>
好比如说：五子棋<br>
面向过程：开始游戏-&gt;描绘画面-&gt;黑子先走-&gt;描绘画面-&gt;白子走-&gt;描绘画面-&gt;判断输赢-&gt;返回或结束<br>
面向对象：棋盘，黑白棋子，规则<br>
先是对象棋盘进行画面的描绘，然后黑白棋对象进行，棋盘对象对其进行检测，规则对象对棋盘对象进行判断<br>
具体我也难解释，写多了自然就会了<br>
我都不知道为啥要把概念弄那么抽象</p>
<h3 id="%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8">类的声明与使用</h3>
<p>属性和行为这是类最基本的两个成员<br>
属性：该类事物的状态信息，即类中的变量<br>
行为：该类事物要做什么操作，或者基于事物的状态能做什么，即类中的方法（函数）</p>
<p>这里将使用两个例子来举例类的使用<br>
可以自行体会一下如何使用类，这是初阶面向对象必须要会的<br>
ArbitrayTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-comment">//属性</span>
    String name;
    <span class="hljs-keyword">double</span> price;

    <span class="hljs-comment">//方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"测试"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String message)</span> </span>{
        System.out.println(message);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"玩游戏"</span>);
    }
}
</div></code></pre>
<p>上述是功能的集成，我们需要一个对象来使用这些功能，以便测试<br>
Test.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest p1 = <span class="hljs-keyword">new</span> ArbitrayTest();
        p1.name = <span class="hljs-string">"xinti Ex"</span>;
        p1.price = <span class="hljs-number">999999</span>;
        System.out.println(<span class="hljs-string">"手机名"</span> + p1.name + <span class="hljs-string">" 价格"</span> + p1.price);
        
        <span class="hljs-comment">//方法的调用</span>
        p1.call();
        p1.sendMessage(<span class="hljs-string">"有内鬼，终止交易"</span>);
        p1.playGame();
    }
}
</div></code></pre>
<p>PersonTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Person p1 = <span class="hljs-keyword">new</span> Person();
        Person p2 = <span class="hljs-keyword">new</span> Person();
        p1.name = <span class="hljs-string">"yhlight"</span>;
        p1.age = <span class="hljs-number">18</span>;
        p1.gender = <span class="hljs-string">'男'</span>;

        p2.name = <span class="hljs-string">"shuiyang"</span>;
        p2.age = <span class="hljs-number">19</span>;
        p2.gender = <span class="hljs-string">'男'</span>;
        System.out.println(<span class="hljs-string">"名字"</span> + p1.name + <span class="hljs-string">" 年龄"</span> + p1.age + <span class="hljs-string">" 性别"</span> + p1.gender);
        System.out.println(<span class="hljs-string">"名字"</span> + p2.name + <span class="hljs-string">" 年龄"</span> + p2.age + <span class="hljs-string">" 性别"</span> + p2.gender);

        p1.eat();
        p1.sleep(<span class="hljs-number">10</span>);
        p2.eat();
        p2.sleep(<span class="hljs-number">8</span>);
    }
}
</div></code></pre>
<p>Person.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    String name;
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">char</span> gender;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"至少吃"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hour)</span> </span>{
        System.out.println(<span class="hljs-string">"人至少保证"</span> + hour + <span class="hljs-string">"小时睡眠"</span>);
    }

}
</div></code></pre>
<h3 id="%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90">类的内存解析</h3>
<p>对象在内存中的分配涉及的内存结构有<br>
-栈：存放方法中定义的变量<br>
-堆：创建出来的结构（new），例如数组和对象，包括对象中的属性<br>
-方法区：存放类的模板<br>
举个例子：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    String name;
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">char</span> gender;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"至少吃"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hour)</span> </span>{
        System.out.println(<span class="hljs-string">"人至少保证"</span> + hour + <span class="hljs-string">"小时睡眠"</span>);
    }

}
</div></code></pre>
<p><a href="https://imgse.com/i/pAweNtA"><img src="https://s21.ax1x.com/2024/10/24/pAweNtA.png" alt="pAweNtA.png"></a></p>
<h4 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%8C%E6%88%90%E5%85%B7%E4%BD%93%E5%8A%9F%E8%83%BD%E7%9A%84%E6%B5%81%E7%A8%8B">面向对象的完成具体功能的流程</h4>
<ol>
<li><strong>创建类，并设计类的内部成员（属性，方法）</strong></li>
<li><strong>创建类的对象</strong></li>
<li><strong>通过对象，调用类中声明的属性或方法</strong></li>
</ol>
<h3 id="%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AE%B2%E8%A7%A3">类的属性讲解</h3>
<p>类的属性通常指的是类中定义的变量<br>
在之前，我们是依据变量的数据类型来对变量进行分类<br>
现在我们可以依据变量在类中定义的位置将变量分为成员变量（或属性）和局部变量</p>
<p>成员变量：在方法之外定义的变量（全局变量）<br>
局部变量：方法内，方法形参，构造器内，构造器形参，代码块内定义的变量</p>
<p>局部变量和成员变量在很多地方都是相似的<br>
例如：</p>
<ol>
<li>定义形式相同</li>
<li>都有着作用域</li>
<li>必须先声明并赋值后再使用</li>
</ol>
<p>不同点在于</p>
<ol>
<li>是否可以使用权限修饰符<br>
权限修饰符有public，protected，缺省，private<br>
权限修饰符表示结构可调用范围大小，我们现在这种默认不写的状态为缺省<br>
属性是可以被权限修饰符修饰的，局部变量则不可以</li>
<li>是否有默认初始化值<br>
属性有，但是局部变量没有</li>
</ol>
<h4 id="%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8">方法的使用</h4>
<pre class="hljs"><code><div>[权限修饰符] [其他修饰符] 返回值类型 方法名([形参列表])[<span class="hljs-keyword">throws</span> 异常列表] {
    方法体的功能代码
<span class="hljs-comment">//[]为非必须内容</span>
}
</div></code></pre>
<p>我们能够使用的权限修饰符有public，protected，缺省，private<br>
缺省是没有符号的，没有写权限修饰符的情况就是缺省</p>
<p>返回值类型：调用完方法后，是否返回一个值<br>
返回值类型有void 无返回类型，基本数据类型，引用数据类型<br>
使用return关键词<br>
值得注意的是，有形参不一定有类型<br>
例如sort()方法，sort()需要传入一个数组，但是他并不需要进行返回<br>
sort()方法是对原来的数组进行更改，这不需要进行返回</p>
<h5 id="%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">如何调用方法</h5>
<p><code>对象.方法([形式参数])</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Person test = <span class="hljs-keyword">new</span> Person();
        test.eat();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    String name;
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">char</span> gender;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"吃饭"</span>);

        sleep(<span class="hljs-number">8</span>);  <span class="hljs-comment">//在java中这是允许的，因为存在一个方法区</span>
        <span class="hljs-comment">//在运行时，方法区先加载了类，然后才是堆创建对象</span>
        <span class="hljs-comment">//顺序结构是运行时代码的读取顺序</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hour)</span> </span>{
        System.out.println(<span class="hljs-string">"人至少"</span> + hour + <span class="hljs-string">"小时睡眠"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">interests</span><span class="hljs-params">(String hobby)</span> </span>{
        String info = <span class="hljs-string">"我的爱好是"</span> + hobby;
        System.out.println(info);
        <span class="hljs-keyword">return</span> info;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">methodTest</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//public void methodTest2() {</span>
            <span class="hljs-comment">//方法内不允许再定义方法</span>
            <span class="hljs-comment">//但是类里面可以再定义类</span>
        <span class="hljs-comment">//}</span>
    }

}
</div></code></pre>
<h4 id="%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD">方法的重载</h4>
<p>在同一个类里面，允许多个同名的方法，只要他们的参数列表不同</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">double</span> i, <span class="hljs-keyword">double</span> j)</span> </span>{

    }

}
</div></code></pre>
<p>来道重载有关的面试题</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{

        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
        System.out.println(arr);

        <span class="hljs-keyword">char</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]{<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>};
        System.out.println(arr1);  <span class="hljs-comment">//输出的不是地址</span>

        <span class="hljs-keyword">boolean</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[]{<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>};
        System.out.println(arr2);
        
    }
}
</div></code></pre>
<h4 id="%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82%E6%96%B9%E6%B3%95">可变个数形参方法</h4>
<p>方法形参的类型确认，但是形参的个数无法确认，这时候可以使用可变个数形参方法<br>
<code>(参数类型 ... 参数名)</code><br>
可变个数形参可以为0个或多个</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>... nums)</span> </span>{
        System.out.println(<span class="hljs-string">"0个参数测试"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>{
        <span class="hljs-comment">//不构成重载，可变个数形参方法实质上是数组的替代品</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
        <span class="hljs-comment">//方法的重载，固定的优先于可变</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span>... nums)</span> </span>{   <span class="hljs-comment">//不允许交换，位置</span>
        <span class="hljs-comment">//方法的重载，固定的优先于可变</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest test = <span class="hljs-keyword">new</span> ArbitrayTest();
        test.print();
        test.print(<span class="hljs-number">1</span>);
        test.print(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
    }
}
</div></code></pre>
<p>估计大多数人都不知道能够应用到哪里，巧了，我也是<br>
n个字符串进行拼接，每一个字符串之间使用某个符号进行分割<br>
如果没有传入字符串，则返回空字符串&quot;&quot;</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest test = <span class="hljs-keyword">new</span> ArbitrayTest();
        String info = test.concat(<span class="hljs-string">"-"</span>, <span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>);
        System.out.println(info);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">concat</span><span class="hljs-params">(String operator, String... strs)</span> </span>{
        String result = <span class="hljs-string">""</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) {
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {
                result += strs[i];
            } <span class="hljs-keyword">else</span> {
                result += (operator + strs[i]);
            }
        }

        <span class="hljs-keyword">return</span> result;
    }
}
</div></code></pre>
<h4 id="%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6">方法参数传递机制</h4>
<p>实参和形参<br>
形参：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参<br>
实参：在调用方法时，方法名后面括号()中的使用的值/变量/表达式称为实际参数，简称实参</p>
<p>Java中，方法的参数传递方式只有一种：值传递（其实可以分成传值和传址，但是面试时还是要回答值传递）<br>
将实际参数值的副本（复制品）传入方法内，而参数本身不受影响<br>
形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参<br>
形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p>
<p>这里面我简单说一下就好了，你引用数据类型是在堆空间里面创建对象的<br>
在栈空间中定义一个引用类型的变量时，这个变量并不直接存储对象的数据<br>
而是存储一个指向堆中对象的“引用”（可以理解为一个地址）<br>
这个引用指向堆空间中对象的首地址</p>
<p>只要你知道，传递的是地址还是数据值，上面那些统统都可以滚蛋</p>
<pre class="hljs"><code><div><span class="hljs-comment">//这是一个很好的说明例子</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">int</span> m = <span class="hljs-number">10</span>;
        ArbitrayTest test = <span class="hljs-keyword">new</span> ArbitrayTest();
        test.method1(m);
        System.out.println(m);

        MyArrays arrs = <span class="hljs-keyword">new</span> MyArrays();
        arrs.num = <span class="hljs-number">10</span>;
        test.method2(arrs);
        System.out.println(arrs.num);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m)</span> </span>{
        m++;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">(MyArrays arrs)</span> </span>{
        arrs.num++;
    }
}
</div></code></pre>
<h4 id="%E9%80%92%E5%BD%92">递归</h4>
<p>何为递归，递归就是方法调用自己<br>
递归分为直接递归，间接递归<br>
间接递归就是A-&gt;B,B-&gt;C,C-&gt;A<br>
递归一定要有终止条件</p>
<p>计算1-5的和</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest test = <span class="hljs-keyword">new</span> ArbitrayTest();
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>;
        <span class="hljs-keyword">int</span> sum = test.getSum(num);
        System.out.println(sum);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> num + getSum(num - <span class="hljs-number">1</span>);
    }
}
</div></code></pre>
<p>计算n的阶乘</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest test = <span class="hljs-keyword">new</span> ArbitrayTest();
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>;
        <span class="hljs-keyword">int</span> sum = test.getRet(num);
        System.out.println(sum);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> num * getRet(num - <span class="hljs-number">1</span>);
    }
}
</div></code></pre>
<p>斐波那契数列<br>
1、1、2、3、5、8、13、21、34、55</p>
<pre class="hljs"><code><div> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest test = <span class="hljs-keyword">new</span> ArbitrayTest();
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;
        <span class="hljs-keyword">int</span> fib = test.getFib(num);
        System.out.println(fib);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span> || num == <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">return</span> getFib(num - <span class="hljs-number">1</span>) + getFib(num - <span class="hljs-number">2</span>);
    }
}
</div></code></pre>
<h4 id="%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0">属性和方法的综合练习</h4>
<ol>
<li>声明一个方法，打印一个棱形，并计算它的面积（使用返回值）<br>
Test.java</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest userTest = <span class="hljs-keyword">new</span> ArbitrayTest();
        userTest.x = <span class="hljs-number">10</span>;
        userTest.y = <span class="hljs-number">8</span>;
        <span class="hljs-keyword">int</span> area = userTest.method1();
        System.out.print(area);
    }
}
</div></code></pre>
<p>ArbitrayTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">int</span> y;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; y; j++) {
                System.out.print(<span class="hljs-string">"*"</span>);
            }
            System.out.println();
        }
        <span class="hljs-keyword">return</span> x * y;
    }

}
</div></code></pre>
<ol start="2">
<li>自定义一个操作int[]的工具类，用于求最大值，最小值，总和，平均数<br>
遍历数组，复制数组，数组反装，数组排序，查找<br>
MyArrays.java</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArrays</span> </span>{

    <span class="hljs-comment">/**
     * 获取int[]数组的最大值
     *
     * <span class="hljs-doctag">@param</span> arr 要获取最大值的数组
     * <span class="hljs-doctag">@return</span> 数组的最大值
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>{
        <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">if</span> (max &lt; arr[i]) {
                max = arr[i];
            }
        }
        <span class="hljs-keyword">return</span> max;
    }

    <span class="hljs-comment">/**
     * 获取int[]数组的最小值
     *
     * <span class="hljs-doctag">@param</span> arr 要获取最小值的数组
     * <span class="hljs-doctag">@return</span> 数组的最小值
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>{
        <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">if</span> (min &gt; arr[i]) {
                min = arr[i];
            }
        }
        <span class="hljs-keyword">return</span> min;
    }

    <span class="hljs-comment">/**
     * 获取int[]数组的元素总和
     *
     * <span class="hljs-doctag">@param</span> arr 要获取元素总和的数组
     * <span class="hljs-doctag">@return</span> 数组的元素总和
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>{
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            sum += arr[i];
        }
        <span class="hljs-keyword">return</span> sum;
    }

    <span class="hljs-comment">/**
     * 获取int[]数组的元素平均值
     *
     * <span class="hljs-doctag">@param</span> arr 要获取元素平均值的数组
     * <span class="hljs-doctag">@return</span> 数组的元素平均值
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAvg</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>{
        <span class="hljs-keyword">return</span> getSum(arr) / arr.length;
    }

    <span class="hljs-comment">/**
     * 打印int[]数组
     *
     * <span class="hljs-doctag">@param</span> arr 要打印的数组
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>{
        System.out.print(<span class="hljs-string">"["</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) {
                System.out.print(arr[i]);
            } <span class="hljs-keyword">else</span> {
                System.out.print(<span class="hljs-string">","</span> + arr[i]);
            }

        }

        System.out.println(<span class="hljs-string">"]"</span>);
    }

    <span class="hljs-comment">/**
     * 复制数组
     *
     * <span class="hljs-doctag">@param</span> arr 要复制的数组
     * <span class="hljs-doctag">@return</span> 一模一样的数组
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] copy(<span class="hljs-keyword">int</span>[] arr) {
        <span class="hljs-keyword">int</span>[] newArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            newArr[i] = arr[i];
        }
        <span class="hljs-keyword">return</span> newArr;
    }

    <span class="hljs-comment">/**
     * 数组的逆序
     *
     * <span class="hljs-doctag">@param</span> arr 要逆序的数组
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = arr.length - <span class="hljs-number">1</span>; i &lt; j; i++, j--) {
            <span class="hljs-keyword">int</span> tmp = arr[i];
            arr[i] = arr[j];
            arr[j] = tmp;
        }
    }

    <span class="hljs-comment">/**
     * 数组的排序
     *
     * <span class="hljs-doctag">@param</span> arr 要排序的数组
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - i - <span class="hljs-number">1</span>; j++) {
                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) {
                    <span class="hljs-keyword">int</span> tmp = arr[j];
                    arr[j] = arr[j + <span class="hljs-number">1</span>];
                    arr[j + <span class="hljs-number">1</span>] = tmp;
                }
            }
        }
    }

    <span class="hljs-comment">/**
     * 线性查找
     *
     * <span class="hljs-doctag">@param</span> arr 要查找的数组
     * <span class="hljs-doctag">@return</span> 所要查找的数字的索引，若未找到，返回-1
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">linearSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> searchInt)</span> </span>{
        <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;
        String output = <span class="hljs-string">"存在数字"</span> + searchInt + <span class="hljs-string">" 索引为&gt;"</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            <span class="hljs-keyword">if</span> (arr[i] == searchInt) {
                <span class="hljs-keyword">if</span> (found) {
                    output += <span class="hljs-string">","</span>;
                }
                output += i;
                found = <span class="hljs-keyword">true</span>;
            }
        }

        <span class="hljs-keyword">if</span> (!found) {
            output = <span class="hljs-string">"不存在数字"</span> + searchInt;
        }

        <span class="hljs-keyword">return</span> output;
    }
}
</div></code></pre>
<p>MyArraySTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArraySTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        MyArrays arrs = <span class="hljs-keyword">new</span> MyArrays();
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]{<span class="hljs-number">34</span>, <span class="hljs-number">56</span>, <span class="hljs-number">223</span>, <span class="hljs-number">2</span>, <span class="hljs-number">56</span>, <span class="hljs-number">24</span>, <span class="hljs-number">33</span>, <span class="hljs-number">67</span>, <span class="hljs-number">778</span>, <span class="hljs-number">45</span>};
        <span class="hljs-keyword">int</span> max = arrs.getMax(arr);
        System.out.println(max);

        <span class="hljs-keyword">int</span> min = arrs.getMin(arr);
        System.out.println(min);

        <span class="hljs-keyword">int</span> sum = arrs.getSum(arr);
        System.out.println(sum);

        <span class="hljs-keyword">int</span> avg = arrs.getAvg(arr);
        System.out.println(avg);

        arrs.print(arr);

        <span class="hljs-keyword">int</span>[] newArr = arrs.copy(arr);
        arrs.print(newArr);

        arrs.reverse(arr);
        arrs.print(arr);

        arrs.sort(arr);
        arrs.print(arr);

        String search = arrs.linearSearch(arr, <span class="hljs-number">56</span>);
        System.out.println(search);
    }
}
</div></code></pre>
<h3 id="%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84">对象数组</h3>
<p>什么是对象数组？<br>
数组的元素为类的对象时，称为对象数组<br>
例如：String[]，MyArrays[]<br>
通过实际例子说明可能好一些，可能会有一些抽象，希望认真看<br>
Test.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest[] arbTest = <span class="hljs-keyword">new</span> ArbitrayTest[<span class="hljs-number">20</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arbTest.length; i++) {
            arbTest[i] = <span class="hljs-keyword">new</span> ArbitrayTest();
            arbTest[i].number = i + <span class="hljs-number">1</span>;
            arbTest[i].state = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>);
            arbTest[i].score = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">101</span>);
        }
        ArbitrayTest showArbTest = <span class="hljs-keyword">new</span> ArbitrayTest();
        showArbTest.show(arbTest);
        showArbTest.sort(arbTest);
        System.out.println();
        showArbTest.show(arbTest);
    }
}
</div></code></pre>
<p>ArbitrayTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{

    <span class="hljs-keyword">int</span> number;
    <span class="hljs-keyword">int</span> state;
    <span class="hljs-keyword">int</span> score;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(ArbitrayTest[] arbTest)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arbTest.length - <span class="hljs-number">1</span>; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arbTest.length - i - <span class="hljs-number">1</span>; j++) {
                <span class="hljs-keyword">if</span> (arbTest[j].score &gt; arbTest[j + <span class="hljs-number">1</span>].score) {
                    ArbitrayTest tmp = arbTest[j];
                    arbTest[j] = arbTest[j + <span class="hljs-number">1</span>];
                    arbTest[j + <span class="hljs-number">1</span>] = tmp;
                }
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(ArbitrayTest[] arbTest)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arbTest.length; i++) {
            <span class="hljs-keyword">if</span> (arbTest[i].state == <span class="hljs-number">3</span>) {
                System.out.println(arbTest[i].number + <span class="hljs-string">" "</span> + arbTest[i].state + <span class="hljs-string">" "</span> + arbTest[i].score);
            }
        }
    }

}
</div></code></pre>
<p>别问我为什么不写注释，主要都是为了培养代码的阅读能力<br>
这些都还不是很复杂的内容，如果这些都看不懂，那确实是没话说了</p>
<h4 id="%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90">对象数组的内存解析</h4>
<p><a href="https://imgse.com/i/pA6y8b9"><img src="https://s21.ax1x.com/2024/11/10/pA6y8b9.png" alt="pA6y8b9.png"></a></p>
<h4 id="package%E5%92%8Cimport">package和import</h4>
<p>package，包，用于指明该文件中定义的类，接口等结构所在的包<br>
相当于一个文件夹<br>
<code>package 顶层包名.子包名;</code>
举个例子<br>
pack1\pack2\PackageTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> pack1.pack2;
</div></code></pre>
<ul>
<li>一个源文件只能有一个声明包的package语句</li>
<li>package语句作为Java源文件的第一条语句出现，若缺省该语句，则指定为无名包</li>
<li>包名，属于标识符，满足标识符命名的规则和规范</li>
<li>包通常使用所在公司域名的倒置：com.yinghuolight.xxx，不能用java开头</li>
<li>包对应于文件系统的目录，package语句中用&quot;.&quot;来指明包(目录)的层次，每&quot;.&quot;一次就表示一层文件目录</li>
<li>同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）</li>
<li>不同的包下可以定义同名的结构（类、接口）</li>
</ul>
<p>import<br>
为了使用定义在其它包中的Java类，需用import语句来显式引入指定包下所需要的类<br>
相当于import语句告诉编译器到哪里去寻找这个类<br>
<code>import 包名.类名;</code></p>
<p>import语句，声明在包的声明和类的声明之间<br>
如果需要导入多个类或接口，那么就并列显式多个import语句即可<br>
如果使用a.*导入结构，表示可以导入a包下的所有的结构，例如，<code>java.util.*</code><br>
如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句<br>
如果已经导入java.a包下的类，那么如果需要使用a包的子包下的类的话，仍然需要导入<br>
如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类</p>
<p>import有一个很特别的例子</p>
<pre class="hljs"><code><div>java.sql.Date
java.util.Date
</div></code></pre>
<p>那么，我要如何同时使用这两个包中的Date类？<br>
我们需要用全类名</p>
<pre class="hljs"><code><div>java.sql.Date date1 = <span class="hljs-keyword">new</span> java.sql.Date();
</div></code></pre>
<h2 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85">面向对象-封装</h2>
<h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B0%81%E8%A3%85">为什么需要封装？</h3>
<p>随着我们系统越来越复杂，类会越来越多，那么类之间的访问边界必须把握好，面向对象的开发原则要遵循“高内聚、低耦合”</p>
<p>高内聚、低耦合是软件工程中的概念，也是UNIX操作系统设计的经典原则<br>
内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量<br>
内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身</p>
<p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉<br>
低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用</p>
<p>就像我们使用洗衣机一样，我们只需要知道如何使用，不需要了解洗衣机的内部结构</p>
<p>我们需要使用权限修饰符进行封装，java规定了四种权限修饰符<br>
private 缺省 protected public</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{

    String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> legs;  <span class="hljs-comment">//请问我要如何限制其他人定义它为负数呢？</span>
    <span class="hljs-comment">//这个时候就需要用到封装</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLegs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l)</span> </span>{
        <span class="hljs-keyword">if</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; l % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
            legs = l;
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"非法"</span>);
        }
        <span class="hljs-comment">//这里只是提供了一个方法，用户多了一种定义方式</span>
        <span class="hljs-comment">//我们还是可以通过xxxx.legs来定义</span>
        <span class="hljs-comment">//这个时候，我们需要完全禁止xxxx.legs这种方式，可以使用private</span>
        <span class="hljs-comment">//private int legs;</span>
    }
}
</div></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">本类内部</th>
<th style="text-align:center">本包内</th>
<th style="text-align:center">其他包子类</th>
<th style="text-align:center">其他包非子类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✗</td>
</tr>
<tr>
<td style="text-align:center">缺省</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✗</td>
<td style="text-align:center">✗</td>
</tr>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✗</td>
<td style="text-align:center">✗</td>
<td style="text-align:center">✗</td>
</tr>
</tbody>
</table>
<p>设计程序，定义两个类，Person和PersonTest<br>
用setAge()设置人的合法年龄（0-130），用getAge返回人的年龄<br>
Person.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{
        <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span> &amp;&amp; a &lt;= <span class="hljs-number">130</span>) {
            age = a;
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"输入有误"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> age;
    }

}
</div></code></pre>
<p>PersonTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Person person = <span class="hljs-keyword">new</span> Person();
        person.setAge(<span class="hljs-number">18</span>);
        System.out.println(person.getAge());
    }
}
</div></code></pre>
<p>设计程序，创建员工数组，并从键盘输入，然后遍历<br>
Employee.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> gender;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">private</span> String phoneNumber;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String n)</span> </span>{
        name = n;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGender</span><span class="hljs-params">(<span class="hljs-keyword">char</span> g)</span> </span>{
        gender = g;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">getGender</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> gender;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{
        age = a;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPhoneNumber</span><span class="hljs-params">(String p)</span> </span>{
        phoneNumber = p;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">setPhoneNumber</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> phoneNumber;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//return "年龄&gt;" + name + "性别&gt;" + gender + "年龄&gt;" + age + "电话号码&gt;" + phoneNumber;</span>
        <span class="hljs-keyword">return</span> name + <span class="hljs-string">"\t"</span> + gender + <span class="hljs-string">"\t\t"</span> + age + <span class="hljs-string">"\t\t"</span> + phoneNumber;
    }
}
</div></code></pre>
<p>EmployeeTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Employee[] emps = <span class="hljs-keyword">new</span> Employee[<span class="hljs-number">2</span>];
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; emps.length; i++) {
            emps[i] = <span class="hljs-keyword">new</span> Employee();
            System.out.println(<span class="hljs-string">"请输入第"</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">"位员工的个人信息"</span>);
            System.out.print(<span class="hljs-string">"姓名&gt;"</span>);
            String name = scan.nextLine();
            System.out.print(<span class="hljs-string">"性别&gt;"</span>);
            <span class="hljs-keyword">char</span> gender = scan.nextLine().charAt(<span class="hljs-number">0</span>);
            System.out.print(<span class="hljs-string">"年龄&gt;"</span>);
            <span class="hljs-keyword">int</span> age = scan.nextInt();
            scan.nextLine();  <span class="hljs-comment">//清除缓冲区</span>
            System.out.print(<span class="hljs-string">"电话&gt;"</span>);
            String phoneNumber = scan.nextLine();

            emps[i].setName(name);
            emps[i].setGender(gender);
            emps[i].setAge(age);
            emps[i].setPhoneNumber(phoneNumber);
        }

        System.out.println(<span class="hljs-string">"--------------员工列表--------------"</span>);
        System.out.println(<span class="hljs-string">"编号\t\t姓名\t\t性别\t\t年龄\t\t电话"</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; emps.length; i++) {
            System.out.println((i + <span class="hljs-number">1</span>) + <span class="hljs-string">"\t\t"</span> + emps[i].getInfo());
        }

        scan.close();
    }
}
</div></code></pre>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E6%9E%84%E9%80%A0%E5%99%A8">面向对象-类-构造器</h3>
<p>在new对象时，直接为当前对象的某个或所有成员变量直接赋值，这种做法叫构造器或者构造方法</p>
<pre class="hljs"><code><div>        [修饰符] <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>{
            [修饰符] 构造器名() {
                <span class="hljs-comment">// 实例初始化代码</span>
            }
            [修饰符] 构造器名(参数列表) {
                <span class="hljs-comment">// 实例初始化代码</span>
            }
        }
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArrays</span> </span>{

    <span class="hljs-keyword">int</span> len;
    <span class="hljs-keyword">int</span> line;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l)</span> </span>{
        len = l;
        line = <span class="hljs-number">9</span>;
    }
</div></code></pre>
<pre class="hljs"><code><div>        MyArrays arrs = <span class="hljs-keyword">new</span> MyArrays(<span class="hljs-number">20</span>);
</div></code></pre>
<p>创建类之后，在没有显式提供任何构造器的情况下，系统会默认提供一个空参的构造器，且构造器权限与类相同<br>
当你显式提供构造器时，系统不再提供构造器<br>
构造器可以重载<br>
至今最大的练习来了<br>
Account.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> balance;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> annuallnterestRate;

    Account(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> b, <span class="hljs-keyword">double</span> a) {
        id = i;
        balance = b;
        annuallnterestRate = a;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
        id = i;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> id;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBalance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> </span>{
        balance = b;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> balance;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAnnuallnterestRate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a)</span> </span>{
        annuallnterestRate = a;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getAnnuallnterestRate</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> annuallnterestRate;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> </span>{
        <span class="hljs-keyword">if</span> (balance &gt;= amount &amp;&amp; amount &gt;= <span class="hljs-number">0</span>) {
            balance -= amount;
            System.out.println(<span class="hljs-string">"成功取出"</span> + amount);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"取款失败，金额不足"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> </span>{
        <span class="hljs-keyword">if</span> (amount &gt;= <span class="hljs-number">0</span>) {
            balance += amount;
            System.out.println(<span class="hljs-string">"成功存入"</span> + amount);
        }
    }

}
</div></code></pre>
<p>Customer.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>{
    <span class="hljs-keyword">private</span> String firstName;
    <span class="hljs-keyword">private</span> String lastName;
    <span class="hljs-keyword">private</span> Account account;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(String f, String l)</span> </span>{
        firstName = f;
        lastName = l;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> firstName;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getlastName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> lastName;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccount</span><span class="hljs-params">(Account a)</span> </span>{
        account = a;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">getAccount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> account;
    }

}
</div></code></pre>
<p>CustomerTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Customer customer = <span class="hljs-keyword">new</span> Customer(<span class="hljs-string">"ying"</span>, <span class="hljs-string">"huolight"</span>);
        Account account = <span class="hljs-keyword">new</span> Account(<span class="hljs-number">114514</span>, <span class="hljs-number">67000</span>, <span class="hljs-number">0.013</span>);

        customer.setAccount(account);  <span class="hljs-comment">//这是一个要点，将Customer类和Account类建立起关系</span>
        <span class="hljs-comment">//这里把地址传了过去，意味着customer类已经有权力对Account类进行修改</span>
        customer.getAccount().deposit(<span class="hljs-number">10000</span>);
        customer.getAccount().withdraw(<span class="hljs-number">6700</span>);

        System.out.println(<span class="hljs-string">"用户 ["</span> + customer.getlastName() + <span class="hljs-string">" "</span> + customer.getFirstName()
                + <span class="hljs-string">"]的帐号ID为"</span> + customer.getAccount().getId() + <span class="hljs-string">" 其账户年利息为"</span> + customer.getAccount().getAnnuallnterestRate() * <span class="hljs-number">100</span> + <span class="hljs-string">"%"</span>
                + <span class="hljs-string">" 目前账户持有金额为"</span> + customer.getAccount().getBalance());
    }
}
</div></code></pre>
<p>上述其实可以使用一个匿名对象<br>
<code>customer.setAccount(new Account(114514, 67000, 0.013));</code></p>
<h2 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E9%98%B6%E9%98%B6%E6%AE%B5%E6%80%A7%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85">面向对象初阶阶段性知识补充</h2>
<h3 id="%E7%B1%BB%E4%B8%AD%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E8%BF%87%E7%A8%8B">类中属性赋值过程</h3>
<p>在类的属性中，可以有多个位置给属性赋值<br>
① 默认初始化<br>
② 显式初始化<br>
③ 构造器中初始化<br>
④ 通过&quot;对象.属性&quot;或&quot;对象.方法&quot;的方式，给属性赋值</p>
<p>这四个位置有一定的顺序，1 - 2 - 3 - 4<br>
后续还会出现代码块，代码块和显式初始化处同一位置<br>
Test.java</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>{
        j = <span class="hljs-number">10</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setJ</span><span class="hljs-params">(<span class="hljs-keyword">int</span> setJ)</span> </span>{
        j = setJ;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getJ</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> j;
    }

}
</div></code></pre>
<p>ArbitrayTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Test ts = <span class="hljs-keyword">new</span> Test();
        ts.setJ(<span class="hljs-number">2</span>);
        System.out.println(ts.getJ());
    }
}
</div></code></pre>
<h2 id="javabean%E6%A6%82%E5%BF%B5">JavaBean（概念）</h2>
<p>JavaBean是一种Java语言写成的可重用组件<br>
符合如下标准的Java类都可以被称为JavaBean</p>
<ol>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ol>
<p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行
打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来
使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何
改变</p>
<h2 id="uml%E7%B1%BB%E5%9B%BE">UML类图</h2>
<p>UML（Unified Modeling Language，统一建模语言），用来描述软件模型和架构的图形化语言<br>
常用的UML工具软件有PowerDesinger，Rose和Enterprise Architect<br>
UML工具软件不仅可以绘制软件开发中所需的各种图表，还可以生成对应的源代码<br>
在软件开发中，使用UML类图可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关联、依赖、聚合等）</p>
<pre class="hljs"><code><div>+表示<span class="hljs-keyword">public</span>类型， -表示<span class="hljs-keyword">private</span>类型，#表示<span class="hljs-keyword">protected</span>类型
方法的写法: 方法的类型(+、-)方法名(参数名:参数类型):返回值类型
斜体表示抽象方法或类
</div></code></pre>
<p><a href="https://imgse.com/i/pA6yMgU"><img src="https://s21.ax1x.com/2024/11/10/pA6yMgU.png" alt="pA6yMgU.png"></a></p>
<h2 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%9B%E9%98%B6">面向对象-进阶</h2>
<h3 id="%E5%85%B3%E9%94%AE%E5%AD%97-this">关键字 this</h3>
<p>在声明一个属性对应的setXxx方法时，通过形参的结构给对应的属性赋值，如果形参名和属性名同名了，要如何区分这两个变量？</p>
<p>可以通过this解决这个问题<br>
使用this修饰的变量表示的是属性</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-keyword">int</span> num;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-keyword">this</span>.num = num;
    }
}
</div></code></pre>
<p>this关键字可以调用的结构有成员变量，方法，构造器</p>
<pre class="hljs"><code><div><span class="hljs-comment">//这一个其实是一个构造函数的例子</span>
<span class="hljs-comment">//为什么要写这么多呢，和方法重载一样</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">int</span> j;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//假设需要初始化50行代码</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
        <span class="hljs-keyword">this</span>();  <span class="hljs-comment">//调用上面那个空参的构造器，必须是首行</span>
        <span class="hljs-keyword">this</span>.i = i;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
        <span class="hljs-keyword">this</span>(i);  <span class="hljs-comment">//调用上面i那个构造器，必须是首行</span>
        <span class="hljs-keyword">this</span>.j = j;
    }
}
</div></code></pre>
<p>在正式进入进阶学习前，请先检验自己代码阅读能力先<br>
以下代码请不要进行学习<br>
Account.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> balance;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(<span class="hljs-keyword">double</span> init_balance)</span> </span>{
        <span class="hljs-keyword">this</span>.balance = init_balance;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> balance;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amt)</span> </span>{
        <span class="hljs-keyword">if</span> (amt &gt;= <span class="hljs-number">0</span>) {
            balance += amt;
            System.out.println(<span class="hljs-string">"成功存入&gt;"</span> + amt);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amt)</span> </span>{
        <span class="hljs-keyword">if</span> (balance &gt;= amt &amp;&amp; amt &gt;= <span class="hljs-number">0</span>) {
            balance -= amt;
            System.out.println(<span class="hljs-string">"成功取出&gt;"</span> + amt);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"输入错误，请重新输入"</span>);
        }
    }
}
</div></code></pre>
<p>Customer.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span> </span>{
    <span class="hljs-keyword">private</span> String firstName;
    <span class="hljs-keyword">private</span> String lastName;
    <span class="hljs-keyword">private</span> Account account;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Customer</span><span class="hljs-params">(String firstName, String lastName)</span> </span>{
        <span class="hljs-keyword">this</span>.firstName = firstName;
        <span class="hljs-keyword">this</span>.lastName = lastName;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> firstName;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> lastName;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAccount</span><span class="hljs-params">(Account account)</span> </span>{
        <span class="hljs-keyword">this</span>.account = account;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Account <span class="hljs-title">getAccount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> account;
    }
}
</div></code></pre>
<p>Bank.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span> </span>{
    <span class="hljs-keyword">private</span> Customer[] customers;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numberOfCustomer;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bank</span><span class="hljs-params">()</span> </span>{
        customers = <span class="hljs-keyword">new</span> Customer[<span class="hljs-number">10</span>];
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCustomer</span><span class="hljs-params">(String firstName, String lastName)</span> </span>{
        Customer cust = <span class="hljs-keyword">new</span> Customer(firstName, lastName);
        customers[numberOfCustomer++] = cust;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumberOfCustomer</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> numberOfCustomer;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Customer <span class="hljs-title">getCustomer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>{
        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt;= numberOfCustomer) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">return</span> customers[index];
    }
}
</div></code></pre>
<p>BankTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BankTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Bank bank = <span class="hljs-keyword">new</span> Bank();

        bank.addCustomer(<span class="hljs-string">"huolight"</span>, <span class="hljs-string">"ying"</span>);
        bank.addCustomer(<span class="hljs-string">"扬"</span>, <span class="hljs-string">"睡"</span>);
        bank.addCustomer(<span class="hljs-string">"小雪"</span>, <span class="hljs-string">"南宫"</span>);
        bank.addCustomer(<span class="hljs-string">"来听"</span>, <span class="hljs-string">"幻"</span>);

        bank.getCustomer(<span class="hljs-number">0</span>).setAccount(<span class="hljs-keyword">new</span> Account(<span class="hljs-number">10000</span>));
        bank.getCustomer(<span class="hljs-number">0</span>).getAccount().withdraw(<span class="hljs-number">6700</span>);
        System.out.println(<span class="hljs-string">"账户余额为&gt;"</span> + bank.getCustomer(<span class="hljs-number">0</span>).getAccount().getBalance());
    }
}
</div></code></pre>
<p><a href="https://imgse.com/i/pA6y3DJ"><img src="https://s21.ax1x.com/2024/11/10/pA6y3DJ.png" alt="pA6y3DJ.png"></a></p>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF">面向对象-继承</h3>
<p>extends 继承<br>
<code>class 新建类 extends 继承类</code><br>
继承类为父类，又名superClass，超类，基类<br>
新建类为子类，又名subClass，派生类<br>
子类会继承父类所有的属性和方法<br>
继承性不影响封装性</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> z;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-comment">//继承了Test类的属性i，j，z</span>
    <span class="hljs-comment">//但是要注意，封装性没有被打破</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;
}
</div></code></pre>
<p>继承的实际体现<br>
Circle.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>{
        <span class="hljs-keyword">this</span>.radius = radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>{
        <span class="hljs-keyword">this</span>.radius = radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * radius * radius;
    }
}
</div></code></pre>
<p>Cylinder.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cylinder</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cylinder</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>{
        <span class="hljs-keyword">this</span>.length = length;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>{
        <span class="hljs-keyword">this</span>.length = length;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> length;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findVolume</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * findArea() * getLength();
    }
}
</div></code></pre>
<p>CylinderTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CylinderTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Cylinder cylinder = <span class="hljs-keyword">new</span> Cylinder();

        cylinder.setLength(<span class="hljs-number">1</span>);
        cylinder.setRadius(<span class="hljs-number">2</span>);
        System.out.println(cylinder.findVolume());
    }
}
</div></code></pre>
<h4 id="%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">方法的重写</h4>
<p>在先前的面向对象封装性的学习中，我们学到了四种权限修饰符<br>
其中有一个我们一直用不上的修饰符protected<br>
protected可以使用在方法的重写方面</p>
<p>什么是方法的重写？<br>
子类所需求的功能父类无法满足时，子类对其父类的方法进行重写称为方法的重写</p>
<p>注意，子类重写的方法的方法名和形参列表必须相同，子类重写的方法的权限不得小于父类<br>
子类不能重写父类中private修饰的方法<br>
若父类的方法的返回值类型为void，子类重写的方法也必须是void<br>
若父类的方法的返回值类型为基础数据类型，子类重写的方法的返回值类型必须与父类相同</p>
<p>若父类的方法的返回值类型为引用数据类型（比如类），子类重写的方法的返回值类型与父类相同或是父类返回类型的子类<br>
可能下面的例子有点绕，但只能是这样了</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ArbitrayTest <span class="hljs-title">hasNumber</span><span class="hljs-params">(ArbitrayTest hasNumber)</span> </span>{
        <span class="hljs-keyword">return</span> hasNumber;
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArbitrayTest</span></span>{
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Test3 <span class="hljs-title">hasNumber</span><span class="hljs-params">(Test3 hasNumber)</span> </span>{
        <span class="hljs-keyword">return</span> hasNumber;
    }
}
</div></code></pre>
<h4 id="super%E5%85%B3%E9%94%AE%E5%AD%97">super关键字</h4>
<p>子类重写了父类的方法，那么子类是否可以使用重写前的方法<br>
在Java中，使用super关键字可以实现以上效果</p>
<p>子类继承父类后，子类中定义了和父类同名的属性，是否可以在子类中区分这两个同名属性<br>
在Java中，也可以使用super来解决，但是我求求你不要定义同名的，别给自己整麻烦</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> j;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> i + j;
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> i * j;  <span class="hljs-comment">//重写成返回乘，这里用的是目前类的i和j</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum2</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.i * <span class="hljs-keyword">super</span>.j;  <span class="hljs-comment">//父类的i和j</span>
        <span class="hljs-comment">//属性一般都是私有化了的，super要修饰protected的属性</span>
        <span class="hljs-comment">//实际开发这种写法是很少的，毕竟有javabean</span>
        <span class="hljs-comment">//就不要乱学代码就好了</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sum3</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.sum();  <span class="hljs-comment">//使用父类，即返回加</span>
    }
}
</div></code></pre>
<h5 id="super%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8">super调用构造器</h5>
<p>子类并不会继承父类的构造器，只能通过super调用父类的构造器</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArbitrayTest</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArbitrayTest</span><span class="hljs-params">()</span> </span>{
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>();
    }
}
</div></code></pre>
<p>若子类构造器没有写this，也没有写super，则默认为super</p>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81">面向对象-多态</h3>
<p>多态，即一个事物的多种形态<br>
在Java中，多态的表现为父类的引用指向子类的对象<br>
<code>Person p2 = new Man();</code><br>
注意的是，Man类是继承Person类的<br>
Person.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">protected</span> String name;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"人吃饭"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"人走路"</span>);
    }

}
</div></code></pre>
<p>PersonTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Person p1 = <span class="hljs-keyword">new</span> Person();  <span class="hljs-comment">//先前的做法</span>

        Person p2 = <span class="hljs-keyword">new</span> Man();  <span class="hljs-comment">//多态</span>
        <span class="hljs-comment">//难点是为什么要用多态性</span>
        p2.eat();
        <span class="hljs-comment">//p2.eat()的执行结果是男人多吃饭，也就是调用了Man类的方法</span>
        <span class="hljs-comment">//但是，如果你按住CTRL并点击eat跳转，我们会跳到Person类</span>
        <span class="hljs-comment">//这就是多态性的应用，也被称为虚拟方法调用，简称虚方法调用，或者叫动态绑定  </span>
    }
}
</div></code></pre>
<p>Man.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">boolean</span> isSmoke;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"男人多吃饭"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"男人应该多走路"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">earn</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"男人要挣钱养家"</span>);
    }

}
</div></code></pre>
<p>Woman.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>{
    <span class="hljs-keyword">boolean</span> isBeauty;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"要控制分量"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"女人要多走路"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">goShopping</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"逛街"</span>);
    }

}
</div></code></pre>
<p>在多态的场景下，调用方法时<br>
编译器认为方法是父类类型的方法<br>
而实际执行是子类重写的父类方法<br>
（编译看左，运行看右）</p>
<p>多态性的前提：</p>
<ol>
<li>方法的重写</li>
<li>类的继承</li>
<li>针对的对象是方法而不是属性</li>
</ol>
<p>多态的好处与弊端：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        PersonTest personTest = <span class="hljs-keyword">new</span> PersonTest();
        personTest.adopt(<span class="hljs-keyword">new</span> Person());
        personTest.adopt(<span class="hljs-keyword">new</span> Man());
        <span class="hljs-comment">//在有多态性时，我们可以直接这样使用子类的方法</span>
    }

    <span class="hljs-comment">//在没有多态性时，我们需要使用方法的重载来实现输出子类</span>
    <span class="hljs-comment">//别问我为什么不直接调用Dog，我想说，我能写出这个东西来</span>
    <span class="hljs-comment">//一定会有我的道理</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adopt</span><span class="hljs-params">(Person person)</span> </span>{
        person.eat();
    }

    <span class="hljs-comment">//有多态性这个不用写了</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adopt</span><span class="hljs-params">(Man man)</span> </span>{
        man.eat();
    }
}

</div></code></pre>
<p>多态的弊端在于<br>
我们创建的对象在内存中尽管加载了相应类的属性和方法<br>
依旧无法直接调用其相应的属性和方法</p>
<p>我们无法直接调用其相应的属性和方法，但是我们可以通过间接的方法调用<br>
这种方法叫做向下调用<br>
将父类降格为子类</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonTest1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Person p1 = <span class="hljs-keyword">new</span> Man();
        <span class="hljs-comment">//p1.earn();  对不起，做不到</span>
        Man m1 = (Man)p1;
        m1.earn();
    }
}
</div></code></pre>
<p>向下转型可能会出现类型转换异常，我们需要避免这种情况<br>
我们可以使用instanceof判断对象是否是类的实例<br>
<code>对象 instanceof 类</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonTest1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Person p1 = <span class="hljs-keyword">new</span> Man();
        <span class="hljs-comment">//p1.earn();  对不起，做不到</span>
        Man m1 = (Man) p1;
        m1.earn();

        <span class="hljs-comment">//类型转换异常，编译器不报错</span>
        <span class="hljs-comment">//运行会报错</span>
        <span class="hljs-comment">//我们建议在使用向下转型之前使用instanceof进行判断</span>
        Person p2 = <span class="hljs-keyword">new</span> Woman();
        <span class="hljs-keyword">if</span>(p2 <span class="hljs-keyword">instanceof</span> Man) {
            Man m2 = (Man) p2;
            m2.isSmoke=<span class="hljs-keyword">true</span>;
        }
    }
}
</div></code></pre>
<h4 id="%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B">多态的应用实例</h4>
<p>GeometricObject.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeometricObject</span> </span>{
    <span class="hljs-keyword">protected</span> String color;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> weight;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">GeometricObject</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">GeometricObject</span><span class="hljs-params">(String color, <span class="hljs-keyword">double</span> weight)</span> </span>{
        <span class="hljs-keyword">this</span>.color = color;
        <span class="hljs-keyword">this</span>.weight = weight;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> color;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(String color)</span> </span>{
        <span class="hljs-keyword">this</span>.color = color;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> weight;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(<span class="hljs-keyword">double</span> weight)</span> </span>{
        <span class="hljs-keyword">this</span>.weight = weight;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;
    }
}
</div></code></pre>
<p>Circle.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GeometricObject</span> </span>{
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> radius;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(String color, <span class="hljs-keyword">double</span> weight, <span class="hljs-keyword">double</span> radius)</span> </span>{
        <span class="hljs-keyword">super</span>(color, weight);
        <span class="hljs-keyword">this</span>.radius = radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>{
        <span class="hljs-keyword">this</span>.radius = radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * radius * radius;
    }
}
</div></code></pre>
<p>Cylinder.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cylinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cylinder</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cylinder</span><span class="hljs-params">(String color, <span class="hljs-keyword">double</span> weight, <span class="hljs-keyword">double</span> radius, <span class="hljs-keyword">double</span> length)</span> </span>{
        <span class="hljs-keyword">super</span>(color, weight, radius);
        <span class="hljs-keyword">this</span>.length = length;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>{
        <span class="hljs-keyword">this</span>.length = length;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> length;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-number">3.14</span> * radius * radius + <span class="hljs-number">2</span> * <span class="hljs-number">3.14</span> * radius * length;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findVolume</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * <span class="hljs-keyword">super</span>.findArea() * getLength();
    }
}
</div></code></pre>
<p>MyRectangle.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GeometricObject</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> heigth;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRectangle</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyRectangle</span><span class="hljs-params">(String color, <span class="hljs-keyword">double</span> weight, <span class="hljs-keyword">double</span> width, <span class="hljs-keyword">double</span> heigth)</span> </span>{
        <span class="hljs-keyword">super</span>(color, weight);
        <span class="hljs-keyword">this</span>.width = width;
        <span class="hljs-keyword">this</span>.heigth = heigth;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width)</span> </span>{
        <span class="hljs-keyword">this</span>.width = width;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getHeigth</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> heigth;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeigth</span><span class="hljs-params">(<span class="hljs-keyword">double</span> heigth)</span> </span>{
        <span class="hljs-keyword">this</span>.heigth = heigth;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findArea</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> width * heigth;
    }
}
</div></code></pre>
<p>MathUtil.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MathUtil</span> </span>{
    <span class="hljs-comment">/**
     * 比较两个几何图形的面积是否相等
     *
     * <span class="hljs-doctag">@param</span> g1
     * <span class="hljs-doctag">@param</span> g2
     * <span class="hljs-doctag">@return</span> true or false
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equalsArea</span><span class="hljs-params">(GeometricObject g1, GeometricObject g2)</span> </span>{
        <span class="hljs-keyword">return</span> g1.findArea() == g2.findArea();
    }

    <span class="hljs-comment">/**
     * 显示几何图形的面积
     *
     * <span class="hljs-doctag">@param</span> g
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayGeometricObjectArea</span><span class="hljs-params">(GeometricObject g)</span> </span>{
        System.out.println(g.findArea());
    }
}
</div></code></pre>
<p>Test.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        GeometricObject g1 = <span class="hljs-keyword">new</span> Cylinder(<span class="hljs-string">"圆柱体"</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);
        GeometricObject g2 = <span class="hljs-keyword">new</span> MyRectangle(<span class="hljs-string">"长方形"</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);
        System.out.println(MathUtil.equalsArea(g1, g2));
        MathUtil.displayGeometricObjectArea(g1);
        MathUtil.displayGeometricObjectArea(g2);
    }
}
</div></code></pre>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-object">面向对象-Object</h3>
<p>类java.lang.Object是类层次结构的根类，即所有的其他类的父类<br>
每一个类都使用Object作为超类</p>
<p>Object类是Java所有类的根父类<br>
Object类中声明的结构（属性，方法）具有通用性<br>
Object类中没有声明属性，提供一个空参的构造器<br>
我们使用Object里面的方法<br>
<a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Object.html">JAVA API Object</a></p>
<p>我们需要去学习equals()，toString()，了解clone()<br>
今后会学习getClass()，wait()，hasCode()，notify()，notifyAll()</p>
<p>其实还有一个finalize()，这个在8版本之后都是被标记为过时，17版本之后标记为将删除<br>
这里就不打算讲了</p>
<h4 id="equals">equals()</h4>
<p>equals() 比较是否相等<br>
<code>对象1.equals(对象2)</code><br>
equals()适用于所有引用数据类型，比较两个对象的地址，返回boolean类型的值<br>
如果比较的是两个String类，且两者对应的字符串都相同时，结果为true<br>
这一点说明了String类和其他引用数据类型的equals()方法不同</p>
<p>与String有着类似情况的有<br>
File类，Date类，包装类等，都重写了equals方法，用于比较对象的实体内容是否相等</p>
<h5 id="%E5%A6%82%E4%BD%95%E9%87%8D%E5%86%99equals">如何重写equals()</h5>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }

        <span class="hljs-comment">//第二判断区，我们要做的就是写这个</span>
    }
</div></code></pre>
<p>手写equals()方法是比较麻烦的，但还是要练习怎么去写一个<br>
你不练也行，实话说，以后都是生成的，只不过是为了培养逻辑思维<br>
我们一般选择使用ALT+INS直接生成</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        YhLight[] yhLights = <span class="hljs-keyword">new</span> YhLight[<span class="hljs-number">3</span>];
        yhLights[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight"</span>);
        yhLights[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight"</span>);
        yhLights[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>);
        System.out.println(yhLights[<span class="hljs-number">0</span>].equals(yhLights[<span class="hljs-number">1</span>]));
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> </span>{
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }

        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> YhLight) {
            YhLight yhLight = (YhLight) o;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.equals(yhLight.name);
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
    }
}
</div></code></pre>
<h4 id="tostring">toString()</h4>
<p>toString() 以字符串形式输出类的信息<br>
<code>对象.toString(对象)</code></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">"@"</span> + Integer.toHexString(hashCode());
}
</div></code></pre>
<p>平时使用System.out.println()去打印引用数据类型时，其实就是使用了toString()</p>
<p>和equals()一样，String类，File类，Date类，包装类等<br>
都重写了toString方法，用于返回实体内容<br>
如String类输出字符串，File输出文件路径</p>
<p>没有重写的自定义类默认输出其地址值<br>
同样，我们也需要重写toString以方便我们使用<br>
你可以选择手动或ALT+INS自动生成</p>
<h2 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%AB%98%E7%BA%A7">面向对象-高级</h2>
<h3 id="static-%E9%9D%99%E6%80%81">static 静态</h3>
<p>在先前学习中，我们所见的成员变量均没有被static修饰，这些成员变量称为实例变量</p>
<p>实例变量跟对象挂钩，不同对象各有一份实例变量<br>
不同对象对同一个实例变量进行修改不会影响到其他对象</p>
<p>若我们想要让一个成员变量被类中的实例共享，即多个对象共用一个成员变量，我们可以使用static修饰，即类变量</p>
<p>另一边，在实际开发中，有一些方法其实是与对象是没有多大关系的，我调用这个方法并不是因为你这个对象<br>
像这种情况下，我们可以使用static修饰方法，使其成为类方法，不需要创建对象即可使用方法<br>
static修饰的属性或方法也被称为静态变量或静态方法</p>
<p>static可以用来修饰属性，方法，代码块，内部类<br>
构造器不能使用static</p>
<p>静态变量和实例变量有着一定程度的区别<br>
不限于</p>
<ol>
<li>个数<br>
静态变量在内存中只有一份，实例变量每一个对象都有一份</li>
<li>内存位置<br>
jdk6及之前，存放在方法区，jdk7之后，存放在堆空间<br>
实例变量则存放在堆空间的对象中</li>
<li>加载时机<br>
静态变量随着类的加载而加载<br>
实例变量随机对象的创建而创建</li>
<li>调用者<br>
静态变量可以被类直接调用，还可以被对象调用<br>
实例变量只能被对象调用</li>
<li>消亡时机<br>
静态变量随着类的卸载而消亡<br>
实例变量对象的消亡而消亡</li>
</ol>
<p>静态方法内部能够调用静态属性和静态方法<br>
但是不能调用其他非静态属性<br>
静态方法可以通过<code>类.静态方法</code>直接调用<br>
同一个类调用可以直接<code>静态方法</code>就可以了<br>
非静态方法则能够调用类中任何方法，通过<code>print()</code>这种形式调用</p>
<h3 id="%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%B4%E8%B6%A3%E9%98%85%E8%AF%BB">单例设计模式（兴趣阅读）</h3>
<h4 id="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0">设计模式概述</h4>
<p><strong>设计模式</strong>是在大量的<code>实践中总结</code>和<code>理论化</code>之后优选的代码结构、编程风格、以及解决问题的思考方式<br>
设计模式免去我们自己再思考和摸索，就像是经典的棋谱，不同的棋局，我们用不同的棋谱，&quot;套路&quot;</p>
<p>经典的设计模式共有23种。每个设计模式均是特定环境下特定问题的处理方法<br>
<a href="https://imgse.com/i/pA65vfH"><img src="https://s21.ax1x.com/2024/11/10/pA65vfH.png" alt="pA65vfH.png"></a></p>
<blockquote>
<p>简单工厂模式并不是23中经典模式的一种，是其中工厂方法模式的简化版<br>
对软件设计模式的研究造就了一本可能是面向对象设计方面最有影响的书籍：《设计模式》：《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）<br>
这几位作者常被称为&quot;四人组（Gang of Four）&quot;，而这本书也就被称为&quot;四人组（或 GoF）&quot;书</p>
</blockquote>
<h5 id="%E4%BD%95%E4%B8%BA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">何为单例模式</h5>
<p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法</p>
<h5 id="%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</h5>
<p>如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将<code>类的构造器的访问权限设置为private</code>，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，<code>只能调用该类的某个静态方法</code>以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<code>该类对象的变量也必须定义成静态的</code></p>
<h5 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">单例模式的两种实现方式</h5>
<h6 id="%E9%A5%BF%E6%B1%89%E5%BC%8F">饿汉式</h6>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{
    <span class="hljs-comment">// 1.私有化构造器</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-comment">// 2.内部提供一个当前类的实例</span>
    <span class="hljs-comment">// 4.此实例也必须静态化</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton single = <span class="hljs-keyword">new</span> Singleton();

    <span class="hljs-comment">// 3.提供公共的静态的方法，返回当前类的对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> single;
    }
}
</div></code></pre>
<h6 id="%E6%87%92%E6%B1%89%E5%BC%8F">懒汉式</h6>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>{
    <span class="hljs-comment">// 1.私有化构造器</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>{
    }
    <span class="hljs-comment">// 2.内部提供一个当前类的实例</span>
    <span class="hljs-comment">// 4.此实例也必须静态化</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton single;
    <span class="hljs-comment">// 3.提供公共的静态的方法，返回当前类的对象</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span>(single == <span class="hljs-keyword">null</span>) {
            single = <span class="hljs-keyword">new</span> Singleton();
        }
        <span class="hljs-keyword">return</span> single;
    }
}
</div></code></pre>
<h5 id="%E9%A5%BF%E6%B1%89%E5%BC%8F-vs-%E6%87%92%E6%B1%89%E5%BC%8F">饿汉式 vs 懒汉式</h5>
<p>饿汉式：</p>
<ul>
<li>特点：<code>立即加载</code>，即在使用类的时候已经将对象创建完毕</li>
<li>优点：实现起来<code>简单</code>；没有多线程安全问题</li>
<li>缺点：当类被加载的时候，会初始化static的实例，静态变量被创建并分配内存空间，从这以后，这个static的实例便一直占着这块内存，直到类被卸载时，静态变量被摧毁，并释放所占有的内存。因此在某些特定条件下会<code>耗费内存</code></li>
</ul>
<p>懒汉式：</p>
<ul>
<li>特点：<code>延迟加载</code>，即在调用静态方法时实例才被创建</li>
<li>优点：实现起来比较简单；当类被加载的时候，static的实例未被创建并分配内存空间，当静态方法第一次被调用时，初始化实例变量，并分配内存，因此在某些特定条件下会<code>节约内存</code></li>
<li>缺点：在多线程环境中，这种实现方法是完全错误的，<code>线程不安全</code>，根本不能保证单例的唯一性
<ul>
<li>说明：在多线程章节，会将懒汉式改造成线程安全的模式</li>
</ul>
</li>
</ul>
<h4 id="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">单例模式的优点及应用场景</h4>
<p>由于单例模式只生成一个实例，减少了<code>系统性能开销</code>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</p>
<p>举例：<br>
<a href="https://imgse.com/i/pA65zpd"><img src="https://s21.ax1x.com/2024/11/10/pA65zpd.png" alt="pA65zpd.png"></a></p>
<p><strong>应用场景</strong></p>
<ul>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用，在整个系统运行过程中，回收站一直维护着仅有的一个实例</li>
<li>Application 也是单例的典型应用</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源</li>
</ul>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%B1%BB-%E4%BB%A3%E7%A0%81%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97">面向对象-类-代码块（初始化块）</h3>
<p>代码块：用来初始化类或对象的信息，主要是他们的成员变量</p>
<pre class="hljs"><code><div>    {

    }

    <span class="hljs-keyword">static</span> {

    }
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Person p1 = <span class="hljs-keyword">new</span> Person();
        p1.eat();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>{
    String name;
    <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"人吃饭"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"人走路"</span>);
    }

    {
        System.out.println(<span class="hljs-string">"114514"</span>);
    }

    <span class="hljs-comment">//代码块只能被static修饰</span>
    <span class="hljs-keyword">static</span> {
        System.out.println(<span class="hljs-string">"415411"</span>);
    }
}
</div></code></pre>
<p>上述代码运行的结果是</p>
<pre class="hljs"><code><div>415411
114514
人吃饭
</div></code></pre>
<p>经过我的测试，只要调用了类，就会运行代码块<br>
类的加载会运行静态代码块<br>
对象的创建会运行非静态代码块<br>
<code>Person.name</code>像这种直接调用类只会加载静态代码块<br>
值得注意的是，静态代码块只会执行一次，因为类只加载一次<br>
非静态代码块会随着对象的创建而运行<br>
也就是可能会运行多次</p>
<p>代码块可以用于初始化属性，声明变量，调用属性或方法，还能输出内容，不过需要区分静态与非静态</p>
<h4 id="%E5%A4%9A%E9%87%8D%E4%BB%A3%E7%A0%81%E5%9D%97">多重代码块</h4>
<pre class="hljs"><code><div>    {
        System.out.println(<span class="hljs-string">"111111"</span>);
    }

    {
        System.out.println(<span class="hljs-string">"222222"</span>);
    }

    <span class="hljs-keyword">static</span> {
        System.out.println(<span class="hljs-string">"333333"</span>);
    }

    <span class="hljs-keyword">static</span> {
        System.out.println(<span class="hljs-string">"444444"</span>);
    }
</div></code></pre>
<p>代码块可以写多个，执行的顺序按照代码的顺序来执行<br>
但实际开发中不必要写多重代码块</p>
<pre class="hljs"><code><div>    {
        System.out.println(<span class="hljs-string">"新用户创建"</span>);
        registrationTime = System.currentTimeMillis();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>{
        userName = System.currentTimeMillis() + <span class="hljs-string">""</span>;
        password = <span class="hljs-string">"123456"</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String userName, String password)</span> </span>{
        <span class="hljs-keyword">this</span>.userName = userName;
        <span class="hljs-keyword">this</span>.password = password;
    }
</div></code></pre>
<p>像这样不同构造器有相同的代码时，我们可以使用代码块来代替<br>
代码块并不是必须的，我们还可以通过构造器调用构造器实现类似效果</p>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"新用户创建"</span>);
        registrationTime = System.currentTimeMillis();
        userName = System.currentTimeMillis() + <span class="hljs-string">""</span>;
        password = <span class="hljs-string">"123456"</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String userName, String password)</span> </span>{
        <span class="hljs-keyword">this</span>();
        <span class="hljs-keyword">this</span>.userName = userName;
        <span class="hljs-keyword">this</span>.password = password;
    }
</div></code></pre>
<h3 id="final-%E5%85%B3%E9%94%AE%E5%AD%97">final 关键字</h3>
<p>final，翻译过来是最终的<br>
final关键字可以修饰类，方法，变量</p>
<p>当final修饰类时，表示类无法被继承<br>
final修饰方法时，方法无法被重写，但可以被重载<br>
final修饰变量时，变量值无法更改</p>
<p>final与static搭配<br>
修饰成员变量时，成员变量兼具两者的效果<br>
这种变量称为全局常量</p>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8A%BD%E8%B1%A1%E7%B1%BB">面向对象-抽象类</h3>
<p>最初设计时，或者设计过程中，将一个类设计成没有具体的实例的类，这样的类称为抽象类</p>
<p>在先前，我们创建过一个几何图形类，以及相应的子类，圆，圆柱，棱形等，你会发现其中定义了求面积，或求周长等通用型方法，这些特征是所属于几何图形类的，然而，几何图形太过于抽象，无法对其求面积，求周长有明确的方法写法，只能交给子类去写方法，父类则是提供了一个方法签名，但是没有方法体，像这样只有方法签名，没有方法体的方法称为抽象方法，在Java中，规定包含抽象方法的类必须是抽象类</p>
<p>我们可以使用abstract来修饰类，声明这是一个抽象类<br>
同样，我们可以使用abstract来修饰方法，声明这是一个抽象方法</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAverage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span></span>;
}
</div></code></pre>
<p>抽象类里面也可以有非抽象方法<br>
子类必须重写父类中所有的抽象方法才可以实例化</p>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1">面向对象-模板方法设计</h3>
<p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式</p>
<p>当功能内部一部分实现是确定的，另一部分实现是不确定的，这时可以把不确定的部分暴露出去，让子类去实现</p>
<p>模板方法设计是基于抽象类的基础来实现的<br>
例如，计算某段代码运行时间</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">spendTime</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();

        code();

        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(<span class="hljs-string">"花费的时间为"</span> + (end - start));
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintPrimeNumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
            System.out.println(<span class="hljs-string">"Hello World"</span>);
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        PrintPrimeNumber primeNumber = <span class="hljs-keyword">new</span> PrintPrimeNumber();
        primeNumber.spendTime();
    }
}
</div></code></pre>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%8E%A5%E5%8F%A3">面向对象-接口</h3>
<p>关键字 interface<br>
接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想<br>
继承是一个&quot;是不是&quot;的is-a关系，而接口实现则是&quot;能不能&quot;的<code>has-a</code>关系</p>
<blockquote>
<p>接口的本质是契约、标准、规范，就像我们的法律一样，制定好后大家都要遵守</p>
</blockquote>
<p>接口内部结构说明<br>
可以声明：<br>
属性必须被public static final共同修饰</p>
<p>方法：<br>
在jdk8之前，只能声明抽象方法，修饰为public abstract<br>
jdk8：新增声明静态方法，默认方法<br>
jdk9：新增声明私有方法</p>
<p>不可以声明：<br>
构造器，因为根本没有</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{

        System.out.println(Flyable.MIX_SPEED);

        ArbitrayTest arbTest = <span class="hljs-keyword">new</span> ArbitrayTest();
        arbTest.fly();

        Flyable.staticMethod();  <span class="hljs-comment">//静态方法，只能被接口调用</span>
        arbTest.defaultMethod();  <span class="hljs-comment">//默认方法</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"飞起来"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">//默认方法可以被重写</span>
        System.out.println(<span class="hljs-string">"默认方法可以被重写"</span>);
    }

}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>{
    <span class="hljs-comment">//可以省略声明</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> MIN_SPEED = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> MIX_SPEED = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">double</span> DEFFER = <span class="hljs-number">1.0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//jdk8之前</span>

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">//jdk 8 静态方法</span>
        System.out.println(<span class="hljs-string">"jdk8静态方法"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">//jkd 8 默认方法</span>
        System.out.println(<span class="hljs-string">"jdk8默认方法"</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">privateMethod</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">//jdk 9 私有方法</span>
        <span class="hljs-comment">//提供一个公用代码区</span>
    }

}
</div></code></pre>
<h4 id="%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB">接口与类的关系</h4>
<p>类可以使用关键字<code>implements</code>接入接口，获取其中的属性和方法<br>
类可以接入多个接口</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyable</span>, <span class="hljs-title">CanAttack</span> </span>{

}
</div></code></pre>
<p>我们称接入接口的方法是实现类</p>
<h4 id="%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF">接口的多继承</h4>
<p>相较于类的单继承，接口能够实现多继承</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AA</span>, <span class="hljs-title">BB</span> </span>{

}
</div></code></pre>
<h4 id="%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7">接口的多态性</h4>
<p><code>接口名 变量名 = new 实现类的对象</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Flyable fly = <span class="hljs-keyword">new</span> Bullet();
        fly.fly();
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> MIN_SPEED = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> MIX_SPEED = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">double</span> DEFFER = <span class="hljs-number">1.0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;

}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bullet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"你妈妈飞了"</span>);
    }
}
</div></code></pre>
<h4 id="%E5%8C%BF%E5%90%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">匿名实现类的创建对象</h4>
<p>太tm抽象了<br>
<code>接口名 变量名 = new 接口名()</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Flyable fly = <span class="hljs-keyword">new</span> Flyable() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>{
                System.out.println(<span class="hljs-string">"抽象啊啊啊啊"</span>);
            }
        };
        fly.fly();
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> MIN_SPEED = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> MIX_SPEED = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">double</span> DEFFER = <span class="hljs-number">1.0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;
}
</div></code></pre>
<h4 id="%E5%8C%BF%E5%90%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">匿名实现类的创建匿名对象</h4>
<p>喵？</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Bullet bullet = <span class="hljs-keyword">new</span> Bullet();
        bullet.ToPrint(<span class="hljs-keyword">new</span> Flyable() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>{
                System.out.println(<span class="hljs-string">"匿名对象我喜欢你"</span>);
            }
        });
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> MIN_SPEED = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> MIX_SPEED = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">double</span> DEFFER = <span class="hljs-number">1.0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bullet</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ToPrint</span><span class="hljs-params">(Flyable fly)</span> </span>{
        fly.fly();
    }
}
</div></code></pre>
<h4 id="%E6%8E%A5%E5%8F%A3%E6%A3%B1%E5%BD%A2%E7%BB%A7%E6%89%BF">接口棱形继承</h4>
<p>棱形继承是C++的说法，这里我直接拿来用了</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interfaceTest1</span>, <span class="hljs-title">interfaceTest2</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Test test = <span class="hljs-keyword">new</span> Test();
        test.defaultMethod();  <span class="hljs-comment">//不允许，发生接口冲突，必须重写</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"棱形继承测试3"</span>);

        toPrint();  <span class="hljs-comment">//自己类的方法</span>
        interfaceTest1.<span class="hljs-keyword">super</span>.defaultMethod();  <span class="hljs-comment">//调用接口1的方法</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toPrint</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"输出"</span>);
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interfaceTest1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"棱形继承测试1"</span>);
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interfaceTest2</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"棱形继承测试2"</span>);
    }
}
</div></code></pre>
<h4 id="%E7%B1%BB%E7%9A%84%E4%BC%98%E5%85%88%E5%8E%9F%E5%88%99">类的优先原则</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Test2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interfaceTest1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Test test = <span class="hljs-keyword">new</span> Test();
        test.defaultMethod();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"棱形继承测试-类"</span>);
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interfaceTest1</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">defaultMethod</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"棱形继承测试-接口"</span>);
    }
}
</div></code></pre>
<h4 id="%E6%8E%A5%E5%8F%A3%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%8E%B0">接口应用的体现</h4>
<p>interface CompareObject</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CompareObject</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span></span>;
}
</div></code></pre>
<p>Circle.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>{
        <span class="hljs-keyword">this</span>.radius = radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>{
        <span class="hljs-keyword">this</span>.radius = radius;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"圆["</span> +
                <span class="hljs-string">"半径="</span> + radius +
                <span class="hljs-string">']'</span>;
    }
}
</div></code></pre>
<p>ComparableCircle.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparableCircle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CompareObject</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComparableCircle</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComparableCircle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> radius)</span> </span>{
        <span class="hljs-keyword">super</span>(radius);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> ComparableCircle) {
            ComparableCircle c = (ComparableCircle) o;

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getRadius() &gt; c.getRadius()) {
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getRadius() &lt; c.getRadius()) {
                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
            <span class="hljs-comment">//第二种写法</span>
<span class="hljs-comment">//            return Double.compare(this.getRadius(), c.getRadius());</span>
<span class="hljs-comment">//        } else {</span>
<span class="hljs-comment">//            return 2;</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
            <span class="hljs-comment">//else只有学习了抛出异常你才能写，目前只能随便写</span>
        }
    }
}
</div></code></pre>
<p>InterfaceTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ComparableCircle c1 = <span class="hljs-keyword">new</span> ComparableCircle(<span class="hljs-number">2.3</span>);
        ComparableCircle c2 = <span class="hljs-keyword">new</span> ComparableCircle(<span class="hljs-number">5.3</span>);
        <span class="hljs-keyword">int</span> compareValue = c1.compareTo(c2);
        <span class="hljs-keyword">if</span> (compareValue &gt; <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"c1大"</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (compareValue &lt; <span class="hljs-number">0</span>) {
            System.out.println(<span class="hljs-string">"c2大"</span>);
        } <span class="hljs-keyword">else</span> {
            System.out.println(<span class="hljs-string">"一样大"</span>);
        }
    }
}
</div></code></pre>
<h3 id="%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98-%E5%86%85%E9%83%A8%E7%B1%BB">类的成员-内部类</h3>
<p>用得很少，其实，应该只有5%，可以考虑只是简单了解<br>
将一个类A定义在另一个类B里面，里面的那个类A就称为<code>内部类</code>，类B则称为<code>外部类</code></p>
<p>具体来说，当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类</p>
<h4 id="%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB">内部类的分类</h4>
<p>鉴于类的位置，可以分为<code>成员内部类</code>和<code>局部内部类</code></p>
<p>成员内部类又分为静态成员内部类，非静态成员内部类<br>
局部内部类分为匿名局部内部类，非匿名局部内部类</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArbitrayTest</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">//构造器</span>
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass2</span> </span>{

        }
    }

    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest</span> </span>{  <span class="hljs-comment">//静态成员内部类</span>

    }

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest2</span> </span>{  <span class="hljs-comment">//非静态成员内部类</span>

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">//方法</span>
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass1</span> </span>{  <span class="hljs-comment">//局部内部类</span>

        }
    }
}
</div></code></pre>
<h4 id="%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3">成员内部类的理解</h4>
<p>从类的角度来看，内部类就是个类，具有类的相关特征<br>
可以声明属性，构造器，代码块，内部类，方法<br>
内部类还可以进行继承，接口<br>
可以使用final，abstract修饰</p>
<p>从外部类的成员的角度来看，内部类可以调用外部类的属性，方法，内部类可以使用四种权限修饰符修饰，private是允许的</p>
<h4 id="%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">成员内部类的实例</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitrayTest.ArbTest arbTest = <span class="hljs-keyword">new</span> ArbitrayTest.ArbTest();  <span class="hljs-comment">//静态成员内部类的创建实例</span>

        ArbitrayTest arbitrayTest = <span class="hljs-keyword">new</span> ArbitrayTest();
        ArbitrayTest.ArbTest2 arbTest2 = arbitrayTest.<span class="hljs-keyword">new</span> ArbTest2();  <span class="hljs-comment">//非静态成员内部类的创建实例</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest</span> </span>{  <span class="hljs-comment">//静态成员内部类</span>

    }

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest2</span> </span>{  <span class="hljs-comment">//非静态成员内部类</span>

    }
}
</div></code></pre>
<h4 id="%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E7%BB%93%E6%9E%84">成员内部类如何调用外部类结构</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    String name = <span class="hljs-string">"测试2"</span>;
    <span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toOuter</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"name&gt;"</span> + name + <span class="hljs-string">" age&gt;"</span> + age);
    }

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest</span> </span>{
        String name = <span class="hljs-string">"测试1"</span>;
        <span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toPrint</span><span class="hljs-params">()</span> </span>{
            System.out.println(name);
            System.out.println(age);

            System.out.println(<span class="hljs-keyword">this</span>.name);
            System.out.println(ArbitrayTest.<span class="hljs-keyword">this</span>.name);

            toOuter();
            ArbitrayTest.<span class="hljs-keyword">this</span>.toOuter();
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toOuter</span><span class="hljs-params">()</span> </span>{
            System.out.println(<span class="hljs-string">"name&gt;"</span> + name + <span class="hljs-string">" age&gt;"</span> + age);
        }
    }
}
</div></code></pre>
<h4 id="%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">局部内部类的基本使用</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">outMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{  <span class="hljs-comment">//局部内部类</span>
            <span class="hljs-comment">//声明属性，方法</span>
        }
    }

    <span class="hljs-comment">//开发中的场景</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Comparable <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//提供实现Comparable接口的类</span>
        <span class="hljs-comment">//方式1：提供了接口实现类的的对象</span>
<span class="hljs-comment">//        class MyComparable implements Comparable {</span>
<span class="hljs-comment">//            public int compareTo(Object o) {</span>
<span class="hljs-comment">//                return 0;</span>
<span class="hljs-comment">//            }</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//        MyComparable m = new MyComparable();</span>
<span class="hljs-comment">//        return m;</span>

        <span class="hljs-comment">//方式2：提供了接口的实现类的匿名对象</span>
<span class="hljs-comment">//        class MyComparable implements Comparable {</span>
<span class="hljs-comment">//            public int compareTo(Object o) {</span>
<span class="hljs-comment">//                return 0;</span>
<span class="hljs-comment">//            }</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//        return new MyComparable();</span>

        <span class="hljs-comment">//方式3：提供了接口匿名实现类的对象</span>
<span class="hljs-comment">//            Comparable c = new Comparable() {</span>
<span class="hljs-comment">//                public int compareTo(Object o) {</span>
<span class="hljs-comment">//                    return 0;</span>
<span class="hljs-comment">//                }</span>
<span class="hljs-comment">//            };</span>
<span class="hljs-comment">//            return c;</span>

        <span class="hljs-comment">//方式4：提供了接口的匿名实现类的匿名对象</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Comparable() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
        };

    }
}
</div></code></pre>
<p>编写一个匿名内部类，它继承Object，并在匿名内部类中，声明一个方法public void test()打印荧火light</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">new</span> Object() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
                System.out.println(<span class="hljs-string">"关注见竹老师谢谢喵"</span>);
            }
        }.test();
    }
}
</div></code></pre>
<h4 id="%E5%86%85%E9%83%A8%E7%B1%BB%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93">内部类知识总结</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClassTest2</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{

        SubA a = <span class="hljs-keyword">new</span> SubA();
        a.method();

        <span class="hljs-comment">//举例1：提供接口匿名实现类的对象</span>
        A a1 = <span class="hljs-keyword">new</span> A() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>{
                System.out.println(<span class="hljs-string">"匿名实现类重写的方法method()"</span>);
            }
        };

        a1.method();

        <span class="hljs-comment">//举例2：提供接口匿名实现类的匿名对象</span>
        <span class="hljs-keyword">new</span> A() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>{
                System.out.println(<span class="hljs-string">"匿名实现类重写的方法method()"</span>);
            }
        }.method();

        <span class="hljs-comment">//举例3：</span>
        SubB s1 = <span class="hljs-keyword">new</span> SubB();
        s1.method1();

        <span class="hljs-comment">//举例4：提供了继承于抽象类的匿名子类的对象</span>
        B b = <span class="hljs-keyword">new</span> B() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>{
                System.out.println(<span class="hljs-string">"继承于抽象类的子类调用的方法"</span>);
            }
        };

        b.method1();
        System.out.println(b.getClass());
        System.out.println(b.getClass().getSuperclass());

        <span class="hljs-comment">//举例5：</span>
        <span class="hljs-keyword">new</span> B() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>{
                System.out.println(<span class="hljs-string">"继承于抽象类的子类调用的方法1"</span>);
            }
        }.method1();

        <span class="hljs-comment">//举例6：</span>
        C c = <span class="hljs-keyword">new</span> C();
        c.method2();

        <span class="hljs-comment">//举例7：提供了一个继承于C的匿名子类的对象</span>
        C c1 = <span class="hljs-keyword">new</span> C() {
        };
        c1.method2();
        System.out.println(c1.getClass());
        System.out.println(c1.getClass().getSuperclass());


        C c2 = <span class="hljs-keyword">new</span> C() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>{
                System.out.println(<span class="hljs-string">"SubC"</span>);
            }
        };
        c2.method2();

    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"SubA"</span>);
    }
}

<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;

}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"SubB"</span>);
    }
}


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"C"</span>);
    }
}
</div></code></pre>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%9E%9A%E4%B8%BE">面向对象-枚举</h3>
<p>枚举类型本质也是类，只不过枚举类型限定了对象的数量</p>
<p>在jdk5之前，程序员自定义枚举类型<br>
jdk5之后，Java提供了关键字enum来快速定义<br>
注意的是，enum定义的枚举类默认继承enum类<br>
并且不要声明这个父类</p>
<h4 id="%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">枚举类的定义</h4>
<p>jdk5之前的定义方式</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{

}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String testName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ArbTest</span><span class="hljs-params">(String testName, <span class="hljs-keyword">int</span> index)</span> </span>{
        <span class="hljs-keyword">this</span>.testName = testName;
        <span class="hljs-keyword">this</span>.index = index;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTestName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> testName;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> index;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArbTest test1 = <span class="hljs-keyword">new</span> ArbTest(<span class="hljs-string">"枚举类测试1"</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArbTest test2 = <span class="hljs-keyword">new</span> ArbTest(<span class="hljs-string">"枚举类测试2"</span>, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArbTest test3 = <span class="hljs-keyword">new</span> ArbTest(<span class="hljs-string">"枚举类测试3"</span>, <span class="hljs-number">3</span>);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArbTest test4 = <span class="hljs-keyword">new</span> ArbTest(<span class="hljs-string">"枚举类测试4"</span>, <span class="hljs-number">4</span>);

}
</div></code></pre>
<p>使用enum来定义枚举类型</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{

}

<span class="hljs-keyword">enum</span> ArbTest {
    test1(<span class="hljs-string">"枚举类测试1"</span>, <span class="hljs-number">1</span>),
    test2(<span class="hljs-string">"枚举类测试2"</span>, <span class="hljs-number">2</span>),
    test3(<span class="hljs-string">"枚举类测试3"</span>, <span class="hljs-number">3</span>),
    test4(<span class="hljs-string">"枚举类测试4"</span>, <span class="hljs-number">4</span>);

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String testName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ArbTest</span><span class="hljs-params">(String testName, <span class="hljs-keyword">int</span> index)</span> </span>{
        <span class="hljs-keyword">this</span>.testName = testName;
        <span class="hljs-keyword">this</span>.index = index;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTestName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> testName;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> index;
    }

}
</div></code></pre>
<h4 id="%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">枚举类常用方法</h4>
<p>String toString()：默认返回的是常量名（对象名）<br>
static 枚举类型[] values()：返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值，是一个静态方法<br>
static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象，要求字符串必须是枚举类对象的“名字”，如不是，会有运行时异常IllegalArgumentException<br>
String name():得到当前枚举常量的名称，建议优先使用toString()<br>
int ordinal():返回当前枚举常量的次序号，默认从0开始</p>
<h4 id="%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">枚举类实现接口</h4>
<p>经典情况<br>
多个对象调用同一个方法</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbTest.test1.toPrint();
    }
}

<span class="hljs-keyword">enum</span> ArbTest implements Arb {
    <span class="hljs-comment">//public static final ArbTest test1 = new ArbTest("枚举类测试1", 1);</span>
    test1(<span class="hljs-string">"枚举类测试1"</span>, <span class="hljs-number">1</span>),
    test2(<span class="hljs-string">"枚举类测试2"</span>, <span class="hljs-number">2</span>),
    test3(<span class="hljs-string">"枚举类测试3"</span>, <span class="hljs-number">3</span>),
    test4(<span class="hljs-string">"枚举类测试4"</span>, <span class="hljs-number">4</span>);

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String testName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ArbTest</span><span class="hljs-params">(String testName, <span class="hljs-keyword">int</span> index)</span> </span>{
        <span class="hljs-keyword">this</span>.testName = testName;
        <span class="hljs-keyword">this</span>.index = index;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toPrint</span><span class="hljs-params">()</span> </span>{
        System.out.println(testName);
        System.out.println(index);
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Arb</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toPrint</span><span class="hljs-params">()</span></span>;
}
</div></code></pre>
<p>枚举类情况<br>
各个对象重写同一方法</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbTest.test1.show();
        ArbTest.test2.show();
        ArbTest.test3.show();
        ArbTest.test4.show();
    }
}

<span class="hljs-keyword">enum</span> ArbTest implements Arb {
    test1(<span class="hljs-string">"枚举类测试1"</span>, <span class="hljs-number">1</span>) {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
            System.out.println(<span class="hljs-string">"对象1"</span>);
        }
    },
    test2(<span class="hljs-string">"枚举类测试2"</span>, <span class="hljs-number">2</span>) {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
            System.out.println(<span class="hljs-string">"对象2"</span>);
        }
    },
    test3(<span class="hljs-string">"枚举类测试3"</span>, <span class="hljs-number">3</span>) {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
            System.out.println(<span class="hljs-string">"对象3"</span>);
        }
    },
    test4(<span class="hljs-string">"枚举类测试4"</span>, <span class="hljs-number">4</span>) {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{
            System.out.println(<span class="hljs-string">"对象4"</span>);
        }
    };

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String testName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index;

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ArbTest</span><span class="hljs-params">(String testName, <span class="hljs-keyword">int</span> index)</span> </span>{
        <span class="hljs-keyword">this</span>.testName = testName;
        <span class="hljs-keyword">this</span>.index = index;
    }
}

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Arb</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;
}
</div></code></pre>
<h4 id="%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90">枚举类实际例子</h4>
<p>使用枚举类，定义员工的状态，并显示出来<br>
EmpolyeeTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmpolyeeTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Employee employee = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">"荧火"</span>, <span class="hljs-number">18</span>, Status.FREE);
        System.out.println(employee.toString());
    }
}
</div></code></pre>
<p>Status.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Status {
    BUSY, FREE, VOCATION, DIMISSION;
}
</div></code></pre>
<p>Employee.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">private</span> Status status;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, Status status)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
        <span class="hljs-keyword">this</span>.status = status;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> Status <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> status;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(Status status)</span> </span>{
        <span class="hljs-keyword">this</span>.status = status;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Employee{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">", status="</span> + status +
                <span class="hljs-string">'}'</span>;
    }
}
</div></code></pre>
<p>使用枚举实现单例模式<br>
jdk5.0之前</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ArbitrayTest</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ArbitrayTest arbitrayTest = <span class="hljs-keyword">new</span> ArbitrayTest();
}
</div></code></pre>
<p>jdk5.0之后</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ArbitrayTest {
    ArbTest;
}
</div></code></pre>
<h4 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%B3%A8%E8%A7%A3-annotation">面向对象-注解 Annotation</h4>
<p>注解是从<code>JDK5.0</code>引入的，以<code>@注解名</code>在代码中存在</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Override</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">@Deprecated</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">@SuppressWarnings</span>(value=”unchecked”)
</div></code></pre>
<p>Annotation可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，还可以添加一些参数值</p>
<p>注解可以在类编译、运行时进行加载，体现不同的功能<br>
注解可以看做是一种注释，通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息</p>
<p>然而注解是可以被编译器或其他程序读取的，程序还可以根据注解的不同，做出相应的处理</p>
<h4 id="%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BD%9C%E7%94%A8">注解的相关作用</h4>
<p><strong>1.生成文档相关的注解</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">@author</span> 标明开发该类模块的作者，多个作者之间使用，分割
<span class="hljs-meta">@version</span> 标明该类模块的版本
<span class="hljs-meta">@see</span> 参考转向，也就是相关主题
<span class="hljs-meta">@since</span> 从哪个版本开始增加的
<span class="hljs-meta">@param</span> 对方法中某参数的说明，如果没有参数就不能写
<span class="hljs-meta">@return</span> 对方法返回值的说明，如果方法的返回值类型是<span class="hljs-keyword">void</span>就不能写
<span class="hljs-meta">@exception</span> 对方法可能抛出的异常进行说明 ，如果方法没有用<span class="hljs-keyword">throws</span>显式抛出的异常就不能写
</div></code></pre>
<p><strong>在编译时进行格式检查(JDK内置的三个基本注解)</strong>
<code>@Override</code>：限定重写父类方法，该注解只能用于方法<br>
<code>@Deprecated</code>：用于表示所修饰的元素(类，方法等)已过时，通常是因为所修饰的结构危险或存在更好的选择<br>
<code>@SuppressWarnings</code>：抑制编译器警告</p>
<p><strong>跟踪代码依赖性，实现替代配置文件功能</strong></p>
<h4 id="%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">基本注解的使用与自定义注解</h4>
<p><code>@Override</code>检测是否对父类进行了重写<br>
class ArbTest {
String name;
int index;</p>
<pre><code>public void toPrint() {
    System.out.println(&quot;测试名&quot; + name + &quot;测试序号&quot; + index);
}
</code></pre>
<p>}</p>
<p>class Test2 extends ArbTest {
@Override  //显示声明是不是重写，相当于保护机制
public void toPrint() {
System.out.println(&quot;测试名&quot; + name + &quot;测试序号&quot; + index);
System.out.println(&quot;第&quot; + index + &quot;次测试&quot;);
}
}</p>
<p>自定义注解要搭配反射用<br>
目前写的只有标识作用<br>
MyAnnotation.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation {
    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> "测试"</span>;
}
</div></code></pre>
<p>ArbitrayTest.java</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-meta">@MyAnnotation</span>() <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-meta">@MyAnnotation</span>(value = <span class="hljs-string">"unused"</span>) <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
    }
}
</div></code></pre>
<h4 id="%E5%85%83%E6%B3%A8%E8%A7%A3">元注解</h4>
<p>对现有的注解进行解释说明的注解<br>
JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它annotation类型作说明</p>
<p><strong>@Target</strong>用于描述注解的使用范围</p>
<ul>
<li>可以通过枚举类型ElementType的10个常量对象来指定</li>
<li>TYPE，METHOD，CONSTRUCTOR，PACKAGE.....</li>
</ul>
<p><strong>@Retention</strong>用于描述注解的生命周期</p>
<ul>
<li>可以通过枚举类型RetentionPolicy的3个常量对象来指定</li>
<li>SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）</li>
<li><code>唯有RUNTIME阶段才能被反射读取到</code></li>
</ul>
<p><strong>@Documented</strong>表明这个注解应该被javadoc工具记录</p>
<p><strong>@Inherited</strong>允许子类继承父类中的注解</p>
<h3 id="junit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">JUnit单元测试</h3>
<p><strong>黑盒测试</strong>不需要写代码，给输入值，看程序是否能够输出期望的值<br>
<strong>白盒测试</strong>需要写代码的，关注程序具体的执行流程</p>
<p>JUnit是由Erich Gamma和Kent Beck编写的一个测试框架（regression testing framework），供Java开发人员编写单元测试之用<br>
<strong>JUnit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能</strong></p>
<p>要使用JUnit，必须在项目的编译路径中<code>引入JUnit的库</code>，即相关的.class文件组成的jar包，jar就是一个压缩包，压缩包都是开发好的第三方（Oracle公司第一方，我们自己第二方，其他都是第三方）工具类，都是以class文件形式存在的</p>
<h4 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8junit">如何使用JUnit</h4>
<p>首先，我们需要下载<a href="https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api">junit</a>的jar包<br>
点击版本号，例如5.11.3，然后在Files那一栏中，点击jdk(xxx KB)，即可以下载，注意，这里使用的是比较新的版本，要搭配一些其他需求文件<br>
在页面中，寻找Compile Dependencies栏，将相关文件都下载</p>
<p>同时，我们还需要下载<a href="https://mvnrepository.com/artifact/org.hamcrest/hamcrest">hamcrest</a>的jar包</p>
<p>在下载完成之后<br>
点击IDEA的文件栏，选择项目结构，库，点击+，添加java<br>
直接导入文件夹或者单独的jar<br>
添加之后会询问你应用在哪个模块，自行选择<br>
然后点击项目结构中的模块，选择依赖，看一看有没有，如果有就点击应用就可以了</p>
<p>我这里使用的文件有</p>
<ol>
<li>hamcrest-3.0.jar</li>
<li>junit-jupiter-api-5.11.3.jar</li>
<li>junit-platform-commons-1.11.3.jar</li>
<li>opentest4j-1.3.0.jar</li>
<li>apiguardian-api-1.1.2.jar</li>
</ol>
<p>在代码上，我们使用@Test标记需要运行的方法</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JUnitTest</span> </span>{

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Hello World"</span>);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"你好，世界"</span>);
        test3();
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"你好"</span>);
    }

}
</div></code></pre>
<p>没错，你可以同时运行多个方法<br>
或者运行单个方法</p>
<h4 id="%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E6%9D%A1%E4%BB%B6">单元测试的条件</h4>
<p>所在的类必须是public，非抽象的，包含唯一无参数构造器<br>
@Test的方法必须是public，非抽象，非静态，void无返回值，()无参数的<br>
yysy，你完全可以写一个满足条件的单元测试方法，然后调用不满足条件的方法</p>
<p>在单元测试方法中，Scanner类失效怎么解决？
打开IDEA帮助菜单，选择编辑自定义虚拟机选项，
在idea64.exe.vmoptions配置文件中加入<code>-Deditable.java.test.console=true</code></p>
<h4 id="%E5%AE%9A%E4%B9%89test%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF">定义test测试方法模板</h4>
<p>打开IDEA设置，编译器，实时模板，新建一个组，起名随意，再新建一个模板，模板名称这个很重要，像你在编译器输入main一样，会弹出一个小窗口，回车就自动生成模板，这里也同理，这里的名称是test</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> test$var1$() {
    $end$;
}
</div></code></pre>
<p>注意，记得点击下方的更改，选择Java<br>
以后输入test就可以直接生成了</p>
<p>注意，以后都是使用单元测试的了，后续的代码看到单元测试不要说什么</p>
<h3 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8C%85%E8%A3%85%E7%B1%BB">面向对象-包装类</h3>
<p>Java提供了两个类型系统，<code>基本数据类型</code>与<code>引用数据类型</code>，使用基本数据类型在于效率，然而要使用对象设计的API或新特性时，基本数据类型并不支持它们的相关特征，我们需要怎么做？<br>
可以使用对应的包装类来将基本数据类型转换为引用数据类型</p>
<h4 id="%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%85%E8%A3%85%E7%B1%BB">有什么包装类</h4>
<p>基本数据类型对于的包装类有</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本数据类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center"><strong>Integer</strong></td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">Double</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center"><strong>Character</strong></td>
</tr>
</tbody>
</table>
<h4 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB">如何使用包装类</h4>
<h5 id="%E4%BD%BF%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8">使用包装类的构造器</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>;
        Integer ii1 = <span class="hljs-keyword">new</span> Integer(i1);  <span class="hljs-comment">//还可以传入String类型，Float类型还可以传入double类型的</span>
        System.out.println(ii1.toString());
    }
    <span class="hljs-comment">//  报错无所谓，能用，只不过是被标记废弃了</span>
}
</div></code></pre>
<h5 id="%E4%BD%BF%E7%94%A8valueof">使用valueOf</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>;
        Integer ii1 = Integer.valueOf(i1);
        System.out.println(ii1.toString());
    }
}
</div></code></pre>
<h4 id="%E5%B0%86%E5%8C%85%E8%A3%85%E7%B1%BB%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">将包装类转换成基本数据类型</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>;
        Integer ii1 = Integer.valueOf(i1);
        <span class="hljs-keyword">int</span> i2 = ii1.intValue();
    }
}
</div></code></pre>
<p>你先别急<br>
在jdk5.0时，有一个新特性，叫做自动装箱和自动拆箱</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//自动装箱</span>
        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>;
        Integer i11 = i1;
        Integer i12 = <span class="hljs-number">10</span>;
        System.out.println(i1);
        System.out.println(i11);
        System.out.println(i12);

        System.out.println();
        
        <span class="hljs-comment">//自动拆箱</span>
        Integer i21 = Integer.valueOf(<span class="hljs-number">10</span>);
        <span class="hljs-keyword">int</span> i2 = i21;
        <span class="hljs-keyword">int</span> i3 = Integer.valueOf(<span class="hljs-number">10</span>);
        System.out.println(i21);
        System.out.println(i2);
        System.out.println(i3);
    }
}
</div></code></pre>
<h4 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E8%A3%85%E7%B1%BB">自定义包装类</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInteger</span> </span>{
    <span class="hljs-keyword">int</span> value;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyInteger</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyInteger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
        <span class="hljs-keyword">this</span>.value = value;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> String.valueOf(value);
    }
}
</div></code></pre>
<h4 id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8Estring">基本数据类型，包装类与String</h4>
<h5 id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%E8%BD%AC%E5%8F%98%E6%88%90string">基本数据类型，包装类转变成String</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>;
        String str = String.valueOf(i1);
        System.out.println(str);  <span class="hljs-comment">//带引号的</span>

        <span class="hljs-keyword">int</span> i11 = <span class="hljs-number">10</span>;
        String str2 = String.valueOf(i11);
        System.out.println(str2);

        <span class="hljs-keyword">int</span> i2 = <span class="hljs-number">11</span>;
        String str3 = i2 + <span class="hljs-string">""</span>;
        System.out.println(str3);
    }
}
</div></code></pre>
<h5 id="string%E8%BD%AC%E5%8F%98%E6%88%90%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB">String转变成基本数据类型，包装类</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        String str = <span class="hljs-string">"11"</span>;
        <span class="hljs-keyword">int</span> i1 = Integer.parseInt(str);  <span class="hljs-comment">//parseXxx，具体自己查API，不可能什么都讲的</span>
    }
}
</div></code></pre>
<h4 id="%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%AD%E6%9C%89%E8%B6%A3%E7%9A%84%E7%8E%B0%E8%B1%A1">包装类中有趣的现象</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitrayTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{

        Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);
        Integer j = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);
        System.out.println(i == j);  <span class="hljs-comment">//false</span>

        Integer x = <span class="hljs-number">1</span>;
        Integer y = <span class="hljs-number">1</span>;
        System.out.println(x == y);  <span class="hljs-comment">//true</span>

        Integer m = <span class="hljs-number">128</span>;
        Integer n = <span class="hljs-number">128</span>;
        System.out.println(m == n);  <span class="hljs-comment">//false</span>

    }
}
</div></code></pre>
<p>具体解释上网查Integer 128 陷阱<br>
具体要明白，要看字节码文件，简单的解释就是为了效率，java预先创建了256个Integer对象<br>
如果输入的值在-128~127区间，则直接返回这个对象<br>
或者说，直接看源代码，IDEA CTRL+n，搜索Integer，CTRL+F12搜索，valueOf</p>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);
    }
</div></code></pre>
<p>注意的是，Float和Double没有这个操作</p>
<h3 id="%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</h3>
<p>在使用计算机语言进行项目开发的过程中，即使程序员把代码写得<code>尽善尽美</code>，在系统的运行过程中仍然会遇到一些问题，因为很多问题不是靠代码能够避免的，比如：<code>客户输入数据的格式问题</code>，<code>读取文件是否存在</code>，<code>网络是否始终保持通畅</code>等等</p>
<ul>
<li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常情况，如果不处理最终会导致JVM的非正常停止</li>
</ul>
<blockquote>
<p>异常指的并不是语法错误和逻辑错误。语法错了，编译不通过，不会产生字节码文件，根本不能运行</p>
<p>代码逻辑错误，只是没有得到想要的结果，例如：求a与b的和，你写成了a-b</p>
</blockquote>
<h4 id="%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8A%9B%E5%87%BA%E6%9C%BA%E5%88%B6">异常的抛出机制</h4>
<p>Java中把不同的异常用不同的类表示，一旦发生某种异常，就<code>创建该异常类型的对象</code>，并且抛出（throw），然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止</p>
<p>对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行，另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免，实在无法避免的，要编写相应的代码进行异常的检测、以及<code>异常的处理</code>，保证代码的<code>健壮性</code></p>
<h4 id="java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB">Java异常体系</h4>
<h5 id="throwable">Throwable</h5>
<p><code>java.lang.Throwable</code> 类是Java程序执行过程中发生的异常事件对应的类的根父类</p>
<p><strong>Throwable中的常用方法</strong></p>
<ul>
<li>
<p><code>public void printStackTrace()</code> 打印异常的详细信息<br>
包含了异常的类型、异常的原因、异常出现的位置、在开发和调试阶段都得使用printStackTrace</p>
</li>
<li>
<p><code>public String getMessage()</code> 获取发生异常的原因</p>
</li>
</ul>
<h5 id="error%E5%92%8Cexception">Error和Exception</h5>
<p>Throwable可分为两类：Error和Exception，分别对应着<code>java.lang.Error</code>与<code>java.lang.Exception</code>两个类</p>
<p><strong>Error</strong>Java虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等严重情况，一般不编写针对性的代码进行处理</p>
<ul>
<li>例如：StackOverflowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）</li>
</ul>
<p><strong>Exception</strong> 其它因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行，否则一旦发生异常，程序也会挂掉，例如：</p>
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
<h5 id="%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8">编译时异常和运行时异常</h5>
<p>Java程序的执行分为编译时过程和运行时过程，有的错误只有在<code>运行时</code>才会发生</p>
<ul>
<li>
<p><strong>编译时期异常</strong>（即checked异常、受检异常） 在代码编译阶段，编译器就能明确<code>警示</code>当前代码<code>可能发生（不是一定发生）</code>xx异常，并<code>明确督促</code>程序员提前编写处理它的代码，如果程序员<code>没有编写</code>对应的异常处理代码，则编译器就会直接判定编译失败，从而不能生成字节码文件，通常，这类异常的发生不是由程序员的代码引起的，或者不是靠加简单判断就可以避免的</p>
</li>
<li>
<p><strong>运行时期异常</strong>（即runtime异常、unchecked异常、非受检异常） 在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示，只有等代码运行起来并确实发生了xx异常，它才能被发现，通常，这类异常是由程序员的代码编写不当引起的，只要稍加判断，或者细心检查就可以避免</p>
<ul>
<li><strong>java.lang.RuntimeException</strong>类及它的子类都是运行时异常</li>
</ul>
</li>
</ul>
<p>【面试题】说说你在开发中常见的异常都有哪些？<br>
开发1-2年：</p>
<pre class="hljs"><code><div>|----编译时异常：(受检异常)在执行javac.exe命令时，出现的异常  
    |----- ClassNotFoundException  
    |----- FileNotFoundException  
    |----- IOException  
|----运行时异常：(非受检异常)在执行java.exe命令时，出现的异常  
    |---- ArrayIndexOutOfBoundsException  
    |---- NullPointerException  
    |---- ClassCastException  
    |---- NumberFormatException  
    |---- InputMismatchException  
    |---- ArithmeticException  
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//运行时异常</span>
<span class="hljs-keyword">import</span> org.junit.Test;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestRuntimeException</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//NullPointerException</span>
        <span class="hljs-keyword">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>][];
        System.out.println(arr[<span class="hljs-number">0</span>].length);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//ClassCastException</span>
        Object obj = <span class="hljs-number">15</span>;
        String str = (String) obj;
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//ArrayIndexOutOfBoundsException</span>
        <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) {
            System.out.println(arr[i]);
        }
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//InputMismatchException</span>
        Scanner input = <span class="hljs-keyword">new</span> Scanner(System.in);
        System.out.print(<span class="hljs-string">"请输入一个整数："</span>);<span class="hljs-comment">//输入非整数</span>
        <span class="hljs-keyword">int</span> num = input.nextInt();
        input.close();
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> b = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//ArithmeticException</span>
        System.out.println(a / b);
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//编译时异常</span>
<span class="hljs-keyword">import</span> org.junit.Test;
<span class="hljs-keyword">import</span> java.io.FileInputStream;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>{
        Class c = Class.forName(<span class="hljs-string">"java.lang.String"</span>);<span class="hljs-comment">//ClassNotFoundException</span>
    }
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>{
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"xxxx.txt"</span>);
        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(file);<span class="hljs-comment">//FileNotFoundException</span>
        <span class="hljs-keyword">int</span> b = fis.read();<span class="hljs-comment">//IOException</span>
        <span class="hljs-keyword">while</span> (b != -<span class="hljs-number">1</span>) {
            System.out.print((<span class="hljs-keyword">char</span>) b);
            b = fis.read();<span class="hljs-comment">//IOException</span>
        }
        fis.close();<span class="hljs-comment">//IOException</span>
    }
</div></code></pre>
<p>在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要<code>检测分母为0</code>，<code>数据为空</code>，<code>输入的不是数据而是字符</code>等<br>
过多的if-else分支会导致程序的<code>代码加长</code>、<code>臃肿</code>，<code>可读性差</code>，程序员需要花很大的精力“<code>堵漏洞</code>”，因此采用异常处理机制</p>
<p>Java采用的异常处理机制，是<code>将异常处理的程序代码集中在一起</code>，与正常的程序代码分开，使得程序简洁、优雅，并易于维护</p>
<p>异常处理的方式一般有两种<br>
方式一：try-catch-finally<br>
方式二：throws + 异常类型</p>
<h4 id="%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8try-catch-finally">捕获异常（try-catch-finally）</h4>
<p>Java提供了异常处理的<strong>抓抛模型</strong></p>
<p>Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时的系统，这个过程称为<code>抛出(throw)异常</code>，一旦抛出，此程序就不执行其后的代码了</p>
<p>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理，如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法，这个过程将一直继续下去，直到异常被处理，这一过程称为<code>捕获(catch)异常</code></p>
<p>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止</p>
<p>try-catch-finally基本结构</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">//可能产生异常的代码</span>
    }
    <span class="hljs-keyword">catch</span>( 异常类型<span class="hljs-number">1</span> e ) {
        <span class="hljs-comment">//当产生异常类型1型异常时的处置措施</span>
    }
    <span class="hljs-keyword">catch</span>( 异常类型<span class="hljs-number">2</span> e ) {
        <span class="hljs-comment">//当产生异常类型2型异常时的处置措施</span>
    }
    <span class="hljs-keyword">finally</span> {
        <span class="hljs-comment">//无论是否发生异常，都无条件执行的语句</span>
    }
</div></code></pre>
<h5 id="finally%E7%9A%84%E4%BD%BF%E7%94%A8">finally的使用</h5>
<p>finally中声明的代码是一定会执行的代码，哪怕在异常处理结构中出现了没处理的异常，finally中的代码也一定会执行<br>
return都救不了你</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> result = test(<span class="hljs-number">10</span>);
        System.out.println(result);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> num;
        } <span class="hljs-keyword">catch</span> (NumberFormatException e) {
            <span class="hljs-keyword">return</span> num--;
        } <span class="hljs-keyword">finally</span> {
            System.out.println(<span class="hljs-string">"test结束"</span>);
            ++num;
        }
    }
}
</div></code></pre>
<p>这道面试题要涉及内存结构中的寄存器，解释不了，我也不懂<br>
如果真要说的话，就是return返回的是一个与num同名的一个临时变量，而不是函数中的这个num<br>
值得注意的是，你要留意到，代码是先执行try，然后finally，再执行其他的</p>
<p>我们在开发中，有一些资源(输入流、输出流，数据库连接、Socket连接等资源)在使用完以后<br>
必须显式的进行关闭操作，否则，GC不会自动的回收这些资源，进而导致内存的泄漏<br>
通常这些语句是写在finally里面<br>
输入流、输出流，数据库连接、Socket连接等资源在内存结构中不止一个指针指向，GC不会认为这是垃圾</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>{
        FileInputStream fis = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"xxxx.txt"</span>);
            fis = <span class="hljs-keyword">new</span> FileInputStream(file);<span class="hljs-comment">//FileNotFoundException</span>
            <span class="hljs-keyword">int</span> b = fis.read();<span class="hljs-comment">//IOException</span>
            <span class="hljs-keyword">while</span> (b != -<span class="hljs-number">1</span>) {
                System.out.print((<span class="hljs-keyword">char</span>) b);
                b = fis.read();<span class="hljs-comment">//IOException</span>
            }
            fis.close();<span class="hljs-comment">//IOException</span>
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">if</span> (fis != <span class="hljs-keyword">null</span>) {
                    fis.close();<span class="hljs-comment">//IOException</span>
                }
            } <span class="hljs-keyword">catch</span> (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</div></code></pre>
<h4 id="throws">throws</h4>
<p>throws常用来处理编译时异常</p>
<pre class="hljs"><code><div>    方法声明 <span class="hljs-keyword">throws</span> 数个异常类
</div></code></pre>
<p>例如</p>
<pre class="hljs"><code><div>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> <span class="hljs-keyword">throws</span> NumberFormatException,NullPointerException </span>{}
</div></code></pre>
<p>throws会把异常对象抛给别人，所以要注意进行异常处理，否则其他方法没法调用</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ArbTest</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">try</span> {
            test03();  <span class="hljs-comment">//未进行异常处理，无法编译，需要经过try-catch结构进行异常处理</span>
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            e.printStackTrace();
        }
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException, IOException </span>{
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"xxxx.txt"</span>);
        FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(file);
        <span class="hljs-keyword">int</span> b = fis.read();
        <span class="hljs-keyword">while</span> (b != -<span class="hljs-number">1</span>) {
            System.out.print((<span class="hljs-keyword">char</span>) b);
            b = fis.read();
        }
        fis.close();
    }
}
</div></code></pre>
<p>在方法的重写方面，throws有一定的要求</p>
<p>子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>{

    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArbTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>{

    }
}
</div></code></pre>
<p>子类抛出的异常类型不能大于父类</p>
<h4 id="%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8-throw%E6%B2%A1%E6%9C%89s">手动抛出异常 throw（没有s）</h4>
<p>为什么要手动抛出异常？<br>
在实际开发中，如果出现不满足具体场景的代码问题，我们有必要手动抛出一个指定类型的异常对象</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Test test = <span class="hljs-keyword">new</span> Test();
        test.registry(-<span class="hljs-number">10</span>);
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-keyword">int</span> id;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>{
        <span class="hljs-keyword">if</span> (id &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>.id = id;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"输入的id违法"</span>);
        }
    }
}
</div></code></pre>
<h4 id="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B">自定义异常类型</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BelowZeroException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>{  <span class="hljs-comment">//或者是RuntimeException</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3387545993124229948L</span>;
    <span class="hljs-comment">//这个UID是给IO流用的，用于辨识什么类</span>
    <span class="hljs-comment">//每一个异常类都有独特的一份</span>
    <span class="hljs-comment">//要自己更改更改</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BelowZeroException</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BelowZeroException</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">super</span>(name);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BelowZeroException</span><span class="hljs-params">(String message, Throwable cause)</span> </span>{
        <span class="hljs-keyword">super</span>(message, cause);
    }
}
</div></code></pre>
<h2 id="%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</h2>
<h3 id="%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B">程序、进程与线程</h3>
<p>**程序（program）**为完成特定任务，用某种语言编写的<code>一组指令的集合</code>，即指<code>一段静态的代码</code>，静态对象</p>
<p>**进程（process）**程序的一次执行过程，或是正在内存中运行的应用程序<br>
每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程<br>
程序是静态的，进程是动态的<br>
进程作为<code>操作系统调度和分配资源的最小单位</code>（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域</p>
<p>**线程（thread）**进程可进一步细化为线程，是程序内部的<code>一条执行路径</code>，一个进程中至少有一个线程<br>
一个进程同一时间若<code>并行</code>执行多个线程，就是支持多线程的<br>
线程作为<code>CPU调度和执行的最小单位</code></p>
<p>一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象，这就使得线程间通信更简便、高效，但多个线程操作共享的系统资源可能就会带来<code>安全的隐患</code></p>
<h3 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6">线程的调度</h3>
<p><strong>分时调度</strong><br>
所有线程<code>轮流使用</code> CPU 的使用权，并且平均分配每个线程占用 CPU 的时间</p>
<p><strong>抢占式调度</strong><br>
让<code>优先级高</code>的线程以<code>较大的概率</code>优先使用CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度</p>
<h3 id="%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B">创建与使用线程</h3>
<h4 id="%E6%96%B9%E5%BC%8F%E4%B8%80-%E7%BB%A7%E6%89%BFthread%E7%B1%BB">方式一 继承Thread类</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        PrintNumber printNumber = <span class="hljs-keyword">new</span> PrintNumber();
        printNumber.start();  <span class="hljs-comment">//不能将start替换成run</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
            }
        }
    }
}
</div></code></pre>
<h4 id="%E6%96%B9%E5%BC%8F%E4%BA%8C-%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">方式二 匿名子类，匿名对象</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">new</span> Thread() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++) {
                    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
                    }
                }
            }
        }.start();
    }
}
</div></code></pre>
<h4 id="%E6%96%B9%E5%BC%8F%E4%B8%89-%E6%8E%A5%E5%85%A5runnable%E6%8E%A5%E5%8F%A3">方式三 接入Runnable接口</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        ArbitraryTest arbTest = <span class="hljs-keyword">new</span> ArbitraryTest();
        Thread t1 = <span class="hljs-keyword">new</span> Thread(arbTest);
        t1.start();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
        }
    }
}
</div></code></pre>
<h4 id="%E6%96%B9%E5%BC%8F%E5%9B%9B-%E5%8C%BF%E5%90%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1">方式四 匿名实现类的匿名对象</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
                }
            }
        }).start();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) {
            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
        }
    }
}
</div></code></pre>
<h4 id="thread%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">Thread常用方法</h4>
<ul>
<li>public Thread() 分配一个新的线程对象</li>
<li>public Thread(String name) 分配一个指定名字的新的线程对象</li>
<li>public Thread(Runnable target) 指定创建线程的目标对象，它实现了Runnable接口中的run方法</li>
<li>public Thread(Runnable target,String name) 分配一个带有指定目标新的线程对象并指定名字</li>
</ul>
<h5 id="currentthread">currentThread()</h5>
<p>获取当前的线程</p>
<h5 id="getname">getName()</h5>
<p><code>Thread.currentThread().getName()</code><br>
获取线程的名字</p>
<h5 id="setname">setName()</h5>
<p><code>Thread.currentThread().setName()</code><br>
设置线程的名字</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Thread.currentThread().setName(<span class="hljs-string">"主线程"</span>);
        PrintNumber printNumber = <span class="hljs-keyword">new</span> PrintNumber();
        printNumber.setName(<span class="hljs-string">"子线程1"</span>);
        printNumber.start();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
            }
        }
    }
}
</div></code></pre>
<h5 id="sleep">sleep()</h5>
<p><code>Thread.sleep()</code><br>
使进程休息多少毫秒</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        PrintNumber printNumber = <span class="hljs-keyword">new</span> PrintNumber();
        printNumber.setName(<span class="hljs-string">"子线程1"</span>);
        printNumber.start();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">try</span> {
                Thread.sleep(<span class="hljs-number">1000</span>);
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }

            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
            }
        }
    }
}
</div></code></pre>
<h5 id="yield">yield()</h5>
<p><code>Thread.yield()</code><br>
释放CPU的执行权，即让其他线程优先</p>
<h5 id="join">join()</h5>
<p><code>对象.join()</code><br>
非静态方法，需要用对象调用<br>
若线程A通过线程B调用join()方法，则线程A进入堵塞状态，直至线程B运行结束</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Thread.currentThread().setName(<span class="hljs-string">"这是主线程"</span>);
        PrintNumber printNumber = <span class="hljs-keyword">new</span> PrintNumber();
        printNumber.setName(<span class="hljs-string">"这是子线程"</span>);
        printNumber.start();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
            }

            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">20</span> == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">try</span> {
                    printNumber.join();
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                }
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + i);
            }
        }
    }
}
</div></code></pre>
<h5 id="isalive">isAlive()</h5>
<p>判断线程是否存活</p>
<h5 id="%E8%BF%87%E6%97%B6%E7%9A%84%E6%96%B9%E6%B3%95">过时的方法</h5>
<h6 id="stop">stop()</h6>
<p>强制停止某个线程</p>
<h6 id="suspendresume">suspend()/resume()</h6>
<p>暂停与恢复线程<br>
可能造成死锁，不建议使用</p>
<h4 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">线程的优先级</h4>
<h5 id="getpriority%E5%92%8Csetpriority">getPriority()和setPriority()</h5>
<p>获取设置线程的优先级</p>
<ul>
<li>Thread类的三个优先级常量
<ul>
<li>MAX_PRIORITY（10） 最高优先级</li>
<li>MIN _PRIORITY（1） 最低优先级</li>
<li>NORM_PRIORITY（5） 普通优先级，默认情况下main线程具有普通优先级</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Thread.currentThread().setName(<span class="hljs-string">"这是主线程"</span>);
        PrintNumber printNumber = <span class="hljs-keyword">new</span> PrintNumber();
        printNumber.setName(<span class="hljs-string">"这是子线程"</span>);
        printNumber.setPriority(<span class="hljs-number">10</span>);
        printNumber.start();

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + Thread.currentThread().getPriority() + <span class="hljs-string">":"</span> + i);
            }

            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">20</span> == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">try</span> {
                    printNumber.join();
                } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                }
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNumber</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + Thread.currentThread().getPriority() + <span class="hljs-string">":"</span> + i);
            }
        }
    }
}
</div></code></pre>
<h4 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">线程的安全问题</h4>
<p>当我们使用多个线程访问<strong>同一资源</strong>（可以是同一个变量、同一个文件、同一条记录等）的时候<br>
若多个线程<code>只有读操作</code>，那么不会发生线程安全问题，但是如果多个线程中对资源有<code>读和写</code>的操作，就容易出现线程安全问题</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Ticket t = <span class="hljs-keyword">new</span> Ticket();
        Thread t1 = <span class="hljs-keyword">new</span> Thread(t);
        Thread t2 = <span class="hljs-keyword">new</span> Thread(t);
        Thread t3 = <span class="hljs-keyword">new</span> Thread(t);

        t1.setName(<span class="hljs-string">"窗口1"</span>);
        t2.setName(<span class="hljs-string">"窗口2"</span>);
        t3.setName(<span class="hljs-string">"窗口3"</span>);

        t1.start();
        t2.start();
        t3.start();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"&gt;"</span> + ticket);
                ticket--;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</div></code></pre>
<p>线程1还没有结束，其他线程就已经进入并执行，导致了种种问题</p>
<h5 id="%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97">同步代码块</h5>
<pre class="hljs"><code><div>    <span class="hljs-keyword">synchronized</span> (同步监视器) {
        需要被同步的代码
    }
</div></code></pre>
<p>同步监视器，俗称锁，决定哪个线程能够执行这个代码<br>
同步监视器可以接受任何类的对象，但是对象必须唯一</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Ticket t = <span class="hljs-keyword">new</span> Ticket();
        Thread t1 = <span class="hljs-keyword">new</span> Thread(t);
        Thread t2 = <span class="hljs-keyword">new</span> Thread(t);
        Thread t3 = <span class="hljs-keyword">new</span> Thread(t);

        t1.setName(<span class="hljs-string">"窗口1"</span>);
        t2.setName(<span class="hljs-string">"窗口2"</span>);
        t3.setName(<span class="hljs-string">"窗口3"</span>);

        t1.start();
        t2.start();
        t3.start();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;
    Object obj = <span class="hljs-keyword">new</span> Object();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {

            <span class="hljs-keyword">synchronized</span> (obj) {  <span class="hljs-comment">//可以写成synchronized (this)，在实现接口的情况下，最常用，这里指的是对象t</span>
                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) {
                    <span class="hljs-comment">// 以防抢锁</span>
                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">10</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                    }

                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"&gt;"</span> + ticket);
                    ticket--;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
    }
}
</div></code></pre>
<h5 id="%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95">同步方法</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Ticket t = <span class="hljs-keyword">new</span> Ticket();
        Thread t1 = <span class="hljs-keyword">new</span> Thread(t);
        Thread t2 = <span class="hljs-keyword">new</span> Thread(t);
        Thread t3 = <span class="hljs-keyword">new</span> Thread(t);

        t1.setName(<span class="hljs-string">"窗口1"</span>);
        t2.setName(<span class="hljs-string">"窗口2"</span>);
        t3.setName(<span class="hljs-string">"窗口3"</span>);

        t1.start();
        t2.start();
        t3.start();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">boolean</span> isFlag = <span class="hljs-keyword">true</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (isFlag) {
            show();
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{  <span class="hljs-comment">//如果方法是非静态的，那么监视器默认为this</span>
        <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">try</span> {
                Thread.sleep(<span class="hljs-number">10</span>);
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }

            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"&gt;"</span> + ticket);
            ticket--;
        } <span class="hljs-keyword">else</span> {
            isFlag = <span class="hljs-keyword">false</span>;
        }
    }
}
</div></code></pre>
<p>值得注意的是，同步代码块和同步方法运行的多线程形式是串行，意味着性能低下</p>
<h4 id="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%BC%8F">线程安全的懒汉式</h4>
<p>懒汉式不安全的演示</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-keyword">static</span> Test test1 = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">static</span> Test test2 = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Thread t1 = <span class="hljs-keyword">new</span> Thread() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                test1 = Test.getInstance();
            }
        };

        Thread t2 = <span class="hljs-keyword">new</span> Thread() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                test2 = Test.getInstance();
            }
        };
        t1.start();
        t2.start();

        <span class="hljs-keyword">try</span> {
            t1.join();
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }

        <span class="hljs-keyword">try</span> {
            t2.join();
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }

        System.out.println(test1);
        System.out.println(test2);
        System.out.println(test1 == test2);
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>{
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test instance = <span class="hljs-keyword">null</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">try</span> {
                Thread.sleep(<span class="hljs-number">100</span>);
            } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
            }
            instance = <span class="hljs-keyword">new</span> Test();
        }
        <span class="hljs-keyword">return</span> instance;
    }
}
</div></code></pre>
<p>如何解决？</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Test <span class="hljs-title">getInstance</span><span class="hljs-params">()</span>
</span></div></code></pre>
<p>方式二</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">synchronized</span> (Test<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>{
                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">100</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                    }
                    instance = <span class="hljs-keyword">new</span> Test();
                }
            }
        }
        <span class="hljs-keyword">return</span> instance;
    }
</div></code></pre>
<p>注意，这个方式可能会遇到指令重排的问题<br>
至于是什么不解释，你只需要作出下列改变就可以了<br>
<code>public static volatile Test instance = null;</code></p>
<h4 id="%E6%AD%BB%E9%94%81">死锁</h4>
<p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        StringBuilder str1 = <span class="hljs-keyword">new</span> StringBuilder();
        StringBuilder str2 = <span class="hljs-keyword">new</span> StringBuilder();

        <span class="hljs-keyword">new</span> Thread() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">synchronized</span> (str1) {
                    str1.append(<span class="hljs-string">"a"</span>);
                    str2.append(<span class="hljs-string">"1"</span>);

                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">200</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                    }

                    <span class="hljs-keyword">synchronized</span> (str2) {
                        str1.append(<span class="hljs-string">"b"</span>);
                        str2.append(<span class="hljs-string">"2"</span>);

                        System.out.println(str1);
                        System.out.println(str2);
                    }
                }
            }
        }.start();

        <span class="hljs-keyword">new</span> Thread() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">synchronized</span> (str2) {
                    str1.append(<span class="hljs-string">"c"</span>);
                    str2.append(<span class="hljs-string">"3"</span>);

<span class="hljs-comment">//                    try {</span>
<span class="hljs-comment">//                        Thread.sleep(200);</span>
<span class="hljs-comment">//                    } catch (InterruptedException e) {</span>
<span class="hljs-comment">//                        throw new RuntimeException(e);</span>
<span class="hljs-comment">//                    }</span>

                    <span class="hljs-keyword">synchronized</span> (str1) {
                        str1.append(<span class="hljs-string">"d"</span>);
                        str2.append(<span class="hljs-string">"4"</span>);

                        System.out.println(str1);
                        System.out.println(str2);
                    }
                }
            }
        }.start();
    }
}
</div></code></pre>
<p><strong>诱发死锁的原因</strong></p>
<ul>
<li>互斥条件</li>
<li>占用且等待</li>
<li>不可抢夺</li>
<li>循环等待<br>
以上4个条件，同时出现就会触发死锁</li>
</ul>
<p>死锁一旦出现，基本很难人为干预，只能尽量规避，可以考虑打破上面的诱发条件<br>
针对条件1：互斥条件基本上无法被破坏。因为线程需要通过互斥解决安全问题<br>
针对条件2：可以考虑一次性申请所有所需的资源，这样就不存在等待的问题<br>
针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源<br>
针对条件4：可以将资源改为线性顺序，申请资源时，先申请序号较小的，这样避免循环等待问题</p>
<h4 id="lock-%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8">Lock 锁的使用</h4>
<p>锁是解决同步安全问题的另一种解决办法</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Ticket t1 = <span class="hljs-keyword">new</span> Ticket();
        Ticket t2 = <span class="hljs-keyword">new</span> Ticket();
        Ticket t3 = <span class="hljs-keyword">new</span> Ticket();

        t1.setName(<span class="hljs-string">"窗口1"</span>);
        t2.setName(<span class="hljs-string">"窗口2"</span>);
        t3.setName(<span class="hljs-string">"窗口3"</span>);

        t1.start();
        t2.start();
        t3.start();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ticket = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {

            <span class="hljs-keyword">try</span> {
                lock.lock();

                <span class="hljs-keyword">if</span> (ticket &gt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">10</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"&gt;"</span> + ticket);
                    ticket--;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">break</span>;
                }

            } <span class="hljs-keyword">finally</span> {
                lock.unlock();
            }
        }
    }
}
</div></code></pre>
<h4 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1">线程的通信</h4>
<p>当我们<code>需要多个线程</code>来共同完成一件任务，并且我们希望他们<code>有规律的执行</code>，那么多线程之间需要一些通信机制，可以协调它们的工作，以此实现多线程共同操作一份数据</p>
<h5 id="%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6">等待唤醒机制</h5>
<p>这是多个线程间的一种<code>协作机制</code>，谈到线程我们经常想到的是线程间的<code>竞争（race）</code>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制</p>
<p>在一个线程满足某个条件时，就进入等待状态（<code>wait() / wait(time)</code>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 <code>notifyAll()</code>来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制</p>
<p>wait  线程不再活动，不再参与调度，进入 <code>wait set</code> 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING，它还要等着别的线程执行一个<code>特别的动作</code>，也即“<code>通知（notify）</code>”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（<code>ready queue</code>）中<br>
notify  则选取所通知对象的 wait set 中的一个线程释放<br>
notifyAll  则释放所通知对象的 wait set 上的全部线程</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        PrintNumber p = <span class="hljs-keyword">new</span> PrintNumber();
        Thread t1 = <span class="hljs-keyword">new</span> Thread(p, <span class="hljs-string">"线程1"</span>);
        Thread t2 = <span class="hljs-keyword">new</span> Thread(p, <span class="hljs-string">"线程2"</span>);

        t1.start();
        t2.start();
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintNumber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
                notify();
                <span class="hljs-keyword">if</span> (number &lt;= <span class="hljs-number">100</span>) {

                    <span class="hljs-keyword">try</span> {
                        Thread.sleep(<span class="hljs-number">100</span>);
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                    }

                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + number);
                    number++;

                    <span class="hljs-keyword">try</span> {
                        wait();  <span class="hljs-comment">//使当前线程进入等待状态，同时释放同步监视器</span>
                    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
    }
}
</div></code></pre>
<p>wait()  使当前线程进入等待状态，同时释放同步监视器<br>
notify()  唤醒处在等待中优先级最高的线程，被唤醒的线程从wait的位置开始执行<br>
notifyAll()  见名知意<br>
注意，不能使用在lock中</p>
<h4 id="%E4%BA%86%E8%A7%A3%E5%85%B6%E4%BB%96%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BD%A2%E5%BC%8F">了解其他创建多线程的形式</h4>
<p>基础阶段你学个蛋</p>
<h5 id="%E5%AE%9E%E7%8E%B0callable%E4%BA%86%E8%A7%A3">实现Callable（了解）</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.util.concurrent.Callable;
<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;
<span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">//3.创建Callable接口实现类的对象</span>
        NumThread numThread = <span class="hljs-keyword">new</span> NumThread();

        <span class="hljs-comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span>
        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(numThread);
        <span class="hljs-comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span>
        <span class="hljs-keyword">new</span> Thread(futureTask).start();
        
<span class="hljs-comment">//      接收返回值</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">//6.获取Callable中call方法的返回值</span>
            <span class="hljs-comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span>
            Object sum = futureTask.get();
            System.out.println(<span class="hljs-string">"总和为："</span> + sum);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        } <span class="hljs-keyword">catch</span> (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

<span class="hljs-comment">//1.创建一个实现Callable的实现类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>{
    <span class="hljs-comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(i);
                sum += i;
            }
        }
        <span class="hljs-keyword">return</span> sum;
    }
}
</div></code></pre>
<p>Callable使用了泛型，属于超纲内容，这里用Object代替</p>
<h5 id="%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91">使用线程池（实际开发）</h5>
<p>前面的你都可以不用，用这个</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间<br>
那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？<br>
可以提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复利用，类似生活中的公共交通工具</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">100</span>;i++) {
            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": "</span> + i);
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">100</span>;i++) {
            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) {
                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": "</span> + i);
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumberThread2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-keyword">int</span> evenSum = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录偶数的和</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= <span class="hljs-number">100</span>;i++){
            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>){
                evenSum += i;
            }
        }
        <span class="hljs-keyword">return</span> evenSum;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolTest</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        <span class="hljs-comment">//1. 提供指定线程数量的线程池</span>
        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);
        ThreadPoolExecutor service1 = (ThreadPoolExecutor) service;
<span class="hljs-comment">//        //设置线程池的属性</span>
<span class="hljs-comment">//        System.out.println(service.getClass());//ThreadPoolExecutor</span>
        service1.setMaximumPoolSize(<span class="hljs-number">50</span>); <span class="hljs-comment">//设置线程池中线程数的上限</span>

        <span class="hljs-comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span>
        service.execute(<span class="hljs-keyword">new</span> NumberThread());<span class="hljs-comment">//适合适用于Runnable</span>
        service.execute(<span class="hljs-keyword">new</span> NumberThread1());<span class="hljs-comment">//适合适用于Runnable</span>

        <span class="hljs-keyword">try</span> {
            Future future = service.submit(<span class="hljs-keyword">new</span> NumberThread2());<span class="hljs-comment">//适合使用于Callable</span>
            System.out.println(<span class="hljs-string">"总和为："</span> + future.get());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        }
        <span class="hljs-comment">//3.关闭连接池</span>
        service.shutdown();
    }
}
</div></code></pre>
<h2 id="%E5%B8%B8%E7%94%A8%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%A1%80api">常用类与基础API</h2>
<p>我使用的版本是jdk22<br>
教程是jdk8<br>
所以会有很多不解释的内容</p>
<h3 id="string">String</h3>
<h4 id="string%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E">String类的声明</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span>
    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span>, <span class="hljs-title">Constable</span>, <span class="hljs-title">ConstantDesc</span>
</span></div></code></pre>
<p>Serializable 可序列化接口，凡是实现此接口的类的对象可以通过网络或本地流进行数据的传输<br>
Comparable 凡是实现此接口的类，其对象都可以比较大小<br>
CharSequence 字符序列</p>
<h4 id="%E5%A3%B0%E6%98%8E%E7%9A%84%E5%B1%9E%E6%80%A7">声明的属性</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value;
</div></code></pre>
<p>jdk8是char[]，jdk9之后是byte[]</p>
<h4 id="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F">字符串常量</h4>
<p>一般情况下字符串都是常量，存储在字符串常量池中，仅有一份<br>
在jdk7之前，常量池存放在方法区，在jdk7及其之后，存放在堆空间</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> javax.xml.transform.Source;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        String s1 = <span class="hljs-string">"Hello"</span>;
        String s2 = <span class="hljs-string">"Hello"</span>;
        String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Hello"</span>);
        String s4 = <span class="hljs-string">"HelloWorld"</span>;
        String s5 = s1 + <span class="hljs-string">"World"</span>;
        <span class="hljs-keyword">final</span> String s6 = <span class="hljs-string">"Hello"</span>;
        String s7 = s6 + <span class="hljs-string">"World"</span>;
        String s8 = <span class="hljs-string">"World"</span>;
        String s9 = s6 + s8;
        <span class="hljs-keyword">final</span> String s10 = <span class="hljs-string">"World"</span>;
        String s11 = s6 + s10;
        System.out.println(s1 == s2);  <span class="hljs-comment">//true</span>
        System.out.println(s1 == s3);  <span class="hljs-comment">//false</span>
        System.out.println(s2 == s3);  <span class="hljs-comment">//false</span>
        System.out.println(s4 == s5);  <span class="hljs-comment">//false</span>
        System.out.println(s7 == s4);  <span class="hljs-comment">//true</span>
        System.out.println(s9 == s4);  <span class="hljs-comment">//false</span>
        System.out.println(s11 == s4);  <span class="hljs-comment">//true</span>
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        System.out.println();
        StringTest s1 = <span class="hljs-keyword">new</span> StringTest();
        StringTest s2 = <span class="hljs-keyword">new</span> StringTest();
        s1.name = <span class="hljs-string">"HelloWorld"</span>;
        s2.name = <span class="hljs-string">"HelloWorld"</span>;
        System.out.println(s1.name == s2.name);  <span class="hljs-comment">//true</span>
        s1.name = <span class="hljs-string">"LoveWorld"</span>;
        System.out.println(s2.name);  <span class="hljs-comment">//还是HelloWorld，要注意一下</span>
        System.out.println(s1.name == s2.name);  <span class="hljs-comment">//false</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> </span>{
    <span class="hljs-keyword">public</span> String name;
}
</div></code></pre>
<h4 id="string%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">String的常用方法</h4>
<p>（1）boolean isEmpty()：字符串是否为空<br>
（2）int length()：返回字符串的长度<br>
（3）String concat(xx)：拼接<br>
（4）boolean equals(Object obj)：比较字符串是否相等，区分大小写<br>
（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写<br>
（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小<br>
（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写<br>
（8）String toLowerCase()：将字符串中大写字母转为小写<br>
（9）String toUpperCase()：将字符串中小写字母转为大写<br>
（10）String trim()：去掉字符串前后空白符<br>
（12）public String intern()：结果在常量池中共享<br>
（13）boolean contains(xx)：是否包含xx<br>
（14）int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1<br>
（15）int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始<br>
（16）int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1<br>
（17）int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索<br>
（18）String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串<br>
（19）String substring(int beginIndex, int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串<br>
（20）char charAt(index)：返回[index]位置的字符<br>
（21）char[] toCharArray()：将此字符串转换为一个新的字符数组返回<br>
（22）static String valueOf(char[] data)：返回指定数组中表示该字符序列的String<br>
（23）static String valueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的String<br>
（24）static String copyValueOf(char[] data)：返回指定数组中表示该字符序列的String<br>
（25）static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的String<br>
（26）boolean startsWith(xx)：测试此字符串是否以指定的前缀开始<br>
（27）boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始<br>
（28）boolean endsWith(xx)：测试此字符串是否以指定的后缀结束<br>
（29）String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的，不支持正则<br>
（30）String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串<br>
（31）String replaceAll(String regex, String replacement)：使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串<br>
（32）String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</p>
<h4 id="stringbuffer%E5%92%8Cstringbulider">StringBuffer和StringBulider</h4>
<p>String：不可变的字符序列<br>
StringBuffer：可变的字符序列，线程安全，JDK1.0声明，效率低<br>
StringBuilder：可变的字符序列，线程不安全，JDK5.0声明，效率高</p>
<p>（1）StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串追加的方式拼接<br>
（2）StringBuffer delete(int start, int end)：删除[start,end)之间字符<br>
（3）StringBuffer deleteCharAt(int index)：删除[index]位置字符<br>
（4）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str<br>
（5）void setCharAt(int index, char c)：替换[index]位置字符<br>
（6）char charAt(int index)：查找指定index位置上的字符<br>
（7）StringBuffer insert(int index, xx)：在[index]位置插入xx<br>
（8）int length()：返回存储的字符数据的长度<br>
（9）StringBuffer reverse()：反转<br>
（10）int indexOf(String str)：在当前字符序列中查询str的第一次出现下标<br>
（11）int indexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的第一次出现下标<br>
（12）int lastIndexOf(String str)：在当前字符序列中查询str的最后一次出现下标<br>
（13）int lastIndexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的最后一次出现下标<br>
（14）String substring(int start)：截取当前字符序列[start,最后]<br>
（15）String substring(int start, int end)：截取当前字符序列[start,end)<br>
（16）String toString()：返回此序列中数据的字符串表示形式<br>
（17）void setLength(int newLength) ：设置当前字符序列长度为newLength</p>
<p>将一个字符串进行反转，将字符串中指定部分进行反转，比如“ab<code>cdef</code>g”反转为”ab<code>fedc</code>g”</p>
<pre class="hljs"><code><div>	<span class="hljs-comment">// 方式一：</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverse1</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{<span class="hljs-comment">// start:2,end:5</span>
		<span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span>) {
			<span class="hljs-comment">// 1.</span>
			<span class="hljs-keyword">char</span>[] charArray = str.toCharArray();
			<span class="hljs-comment">// 2.</span>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start, j = end; i &lt; j; i++, j--) {
				<span class="hljs-keyword">char</span> temp = charArray[i];
				charArray[i] = charArray[j];
				charArray[j] = temp;
			}
			<span class="hljs-comment">// 3.</span>
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(charArray);

		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

	}

	<span class="hljs-comment">// 方式二：</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverse2</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
		<span class="hljs-comment">// 1.</span>
		String newStr = str.substring(<span class="hljs-number">0</span>, start);<span class="hljs-comment">// ab</span>
		<span class="hljs-comment">// 2.</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = end; i &gt;= start; i--) {
			newStr += str.charAt(i);
		} <span class="hljs-comment">// abfedc</span>
			<span class="hljs-comment">// 3.</span>
		newStr += str.substring(end + <span class="hljs-number">1</span>);
		<span class="hljs-keyword">return</span> newStr;
	}

	<span class="hljs-comment">// 方式三：推荐 （相较于方式二做的改进）</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverse3</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{<span class="hljs-comment">// ArrayList list = new ArrayList(80);</span>
		<span class="hljs-comment">// 1.</span>
		StringBuffer s = <span class="hljs-keyword">new</span> StringBuffer(str.length());
		<span class="hljs-comment">// 2.</span>
		s.append(str.substring(<span class="hljs-number">0</span>, start));<span class="hljs-comment">// ab</span>
		<span class="hljs-comment">// 3.</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = end; i &gt;= start; i--) {
			s.append(str.charAt(i));
		}

		<span class="hljs-comment">// 4.</span>
		s.append(str.substring(end + <span class="hljs-number">1</span>));

		<span class="hljs-comment">// 5.</span>
		<span class="hljs-keyword">return</span> s.toString();

	}

	<span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testReverse</span><span class="hljs-params">()</span> </span>{
		String str = <span class="hljs-string">"abcdefg"</span>;
		String str1 = reverse3(str, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>);
		System.out.println(str1);<span class="hljs-comment">// abfedcg</span>

	}
</div></code></pre>
<p>获取一个字符串在另一个字符串中出现的次数<br>
获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数</p>
<pre class="hljs"><code><div>	<span class="hljs-comment">// 判断str2在str1中出现的次数</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">(String mainStr, String subStr)</span> </span>{
		<span class="hljs-keyword">if</span> (mainStr.length() &gt;= subStr.length()) {
			<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
			<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
			<span class="hljs-comment">// while((index = mainStr.indexOf(subStr)) != -1){</span>
			<span class="hljs-comment">// count++;</span>
			<span class="hljs-comment">// mainStr = mainStr.substring(index + subStr.length());</span>
			<span class="hljs-comment">// }</span>
			<span class="hljs-comment">// 改进：</span>
			<span class="hljs-keyword">while</span> ((index = mainStr.indexOf(subStr, index)) != -<span class="hljs-number">1</span>) {
				index += subStr.length();
				count++;
			}

			<span class="hljs-keyword">return</span> count;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		}

	}

	<span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetCount</span><span class="hljs-params">()</span> </span>{
		String str1 = <span class="hljs-string">"cdabkkcadkabkebfkabkskab"</span>;
		String str2 = <span class="hljs-string">"ab"</span>;
		<span class="hljs-keyword">int</span> count = getCount(str1, str2);
		System.out.println(count);
	}
</div></code></pre>
<p>获取两个字符串中最大相同子串<br>
str1 = &quot;abcwerthelloyuiodef“;str2 = &quot;cvhellobnm&quot;<br>
将短的那个串进行长度依次递减的子串与较长的串比较</p>
<pre class="hljs"><code><div>	<span class="hljs-comment">// 如果只存在一个最大长度的相同子串</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMaxSameSubString</span><span class="hljs-params">(String str1, String str2)</span> </span>{
		<span class="hljs-keyword">if</span> (str1 != <span class="hljs-keyword">null</span> &amp;&amp; str2 != <span class="hljs-keyword">null</span>) {
			String maxStr = (str1.length() &gt; str2.length()) ? str1 : str2;
			String minStr = (str1.length() &gt; str2.length()) ? str2 : str1;

			<span class="hljs-keyword">int</span> len = minStr.length();

			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {<span class="hljs-comment">// 0 1 2 3 4 此层循环决定要去几个字符</span>

				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = len - i; y &lt;= len; x++, y++) {

					<span class="hljs-keyword">if</span> (maxStr.contains(minStr.substring(x, y))) {

						<span class="hljs-keyword">return</span> minStr.substring(x, y);
					}

				}

			}
		}
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
	}

	<span class="hljs-comment">// 如果存在多个长度相同的最大相同子串</span>
	<span class="hljs-comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span>
	<span class="hljs-keyword">public</span> String[] getMaxSameSubString1(String str1, String str2) {
		<span class="hljs-keyword">if</span> (str1 != <span class="hljs-keyword">null</span> &amp;&amp; str2 != <span class="hljs-keyword">null</span>) {
			StringBuffer sBuffer = <span class="hljs-keyword">new</span> StringBuffer();
			String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;
			String minString = (str1.length() &gt; str2.length()) ? str2 : str1;

			<span class="hljs-keyword">int</span> len = minString.length();
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = len - i; y &lt;= len; x++, y++) {
					String subString = minString.substring(x, y);
					<span class="hljs-keyword">if</span> (maxString.contains(subString)) {
						sBuffer.append(subString + <span class="hljs-string">","</span>);
					}
				}
				System.out.println(sBuffer);
				<span class="hljs-keyword">if</span> (sBuffer.length() != <span class="hljs-number">0</span>) {
					<span class="hljs-keyword">break</span>;
				}
			}
			String[] split = sBuffer.toString().replaceAll(<span class="hljs-string">",$"</span>, <span class="hljs-string">""</span>).split(<span class="hljs-string">"\\,"</span>);
			<span class="hljs-keyword">return</span> split;
		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
	}
	<span class="hljs-comment">// 如果存在多个长度相同的最大相同子串：使用ArrayList</span>
<span class="hljs-comment">//	public List&lt;String&gt; getMaxSameSubString1(String str1, String str2) {</span>
<span class="hljs-comment">//		if (str1 != null &amp;&amp; str2 != null) {</span>
<span class="hljs-comment">//			List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="hljs-comment">//			String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;</span>
<span class="hljs-comment">//			String minString = (str1.length() &gt; str2.length()) ? str2 : str1;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//			int len = minString.length();</span>
<span class="hljs-comment">//			for (int i = 0; i &lt; len; i++) {</span>
<span class="hljs-comment">//				for (int x = 0, y = len - i; y &lt;= len; x++, y++) {</span>
<span class="hljs-comment">//					String subString = minString.substring(x, y);</span>
<span class="hljs-comment">//					if (maxString.contains(subString)) {</span>
<span class="hljs-comment">//						list.add(subString);</span>
<span class="hljs-comment">//					}</span>
<span class="hljs-comment">//				}</span>
<span class="hljs-comment">//				if (list.size() != 0) {</span>
<span class="hljs-comment">//					break;</span>
<span class="hljs-comment">//				}</span>
<span class="hljs-comment">//			}</span>
<span class="hljs-comment">//			return list;</span>
<span class="hljs-comment">//		}</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//		return null;</span>
<span class="hljs-comment">//	}</span>

	<span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetMaxSameSubString</span><span class="hljs-params">()</span> </span>{
		String str1 = <span class="hljs-string">"abcwerthelloyuiodef"</span>;
		String str2 = <span class="hljs-string">"cvhellobnmiodef"</span>;
		String[] strs = getMaxSameSubString1(str1, str2);
		System.out.println(Arrays.toString(strs));
	}
</div></code></pre>
<p>对字符串中字符进行自然顺序排序<br>
1）字符串变成字符数组<br>
2）对数组排序，选择，冒泡，Arrays.sort();<br>
3）将排序后的数组变成字符串</p>
<pre class="hljs"><code><div>	<span class="hljs-meta">@Test</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSort</span><span class="hljs-params">()</span> </span>{
		String str = <span class="hljs-string">"abcwerthelloyuiodef"</span>;
		<span class="hljs-keyword">char</span>[] arr = str.toCharArray();
		Arrays.sort(arr);

		String newStr = <span class="hljs-keyword">new</span> String(arr);
		System.out.println(newStr);
	}
</div></code></pre>
<h3 id="date-%E6%97%A5%E6%9C%9F">Date 日期</h3>
<h4 id="jdk8%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9Fapi">JDK8之前的日期API</h4>
<h5 id="systemcurrenttimemillis-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E5%AF%B9%E5%BA%94%E7%9A%84%E6%AF%AB%E7%A7%92%E6%95%B0">System.currentTimeMillis() 获取当前时间对应的毫秒数</h5>
<p>我们先前拿来测试代码的运行时间</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) {
            System.out.println(<span class="hljs-string">"你好世界"</span>);
        }
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
</div></code></pre>
<p>System.currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</p>
<h5 id="date%E7%B1%BB">Date类</h5>
<h6 id="javautildate">java.util.Date</h6>
<h6 id="javasqldate%E5%AD%90%E7%B1%BB">java.sql.Date（子类）</h6>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Date t1 = <span class="hljs-keyword">new</span> Date();
        System.out.println(t1.toString());  <span class="hljs-comment">//打印日期</span>
        <span class="hljs-keyword">long</span> time = t1.getTime();
        System.out.println(time);  <span class="hljs-comment">//获取对应的毫秒数</span>
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//Date(long)</span>
        Date date2 = <span class="hljs-keyword">new</span> Date(<span class="hljs-number">1735390042213L</span>);  <span class="hljs-comment">//指定时间的Date对象</span>
        System.out.println(date2.toString());
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>{
        java.sql.Date date1 = <span class="hljs-keyword">new</span> java.sql.Date(<span class="hljs-number">1735390042213L</span>);  <span class="hljs-comment">//Date(long)</span>
        System.out.println(date1.toString());
        System.out.println(date1.getTime());
    }
}
</div></code></pre>
<h5 id="simpledateformat%E7%B1%BB">SimpleDateFormat类</h5>
<p>SimpleDateFormat类用于日期时间的格式化和解析</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.text.ParseException;
<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException </span>{
        SimpleDateFormat formatter = <span class="hljs-keyword">new</span> SimpleDateFormat();
        Date date = <span class="hljs-keyword">new</span> Date();
        String strDate = formatter.format(date);
        System.out.println(strDate);
        Date date2 = formatter.parse(<span class="hljs-string">"2024/12/28 21:30"</span>);
        System.out.println(date2);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//自己上API找例子</span>
        SimpleDateFormat formatter = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy.MM.dd G 'at' HH:mm:ss z"</span>);
        formatter = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd-HH:mm:ss"</span>);
        Date date1 = <span class="hljs-keyword">new</span> Date();
        String strDate = formatter.format(date1);
        System.out.println(strDate);
    }
}
</div></code></pre>
<h4 id="calendar-%E6%8A%BD%E8%B1%A1%E7%B1%BB">Calendar 抽象类</h4>
<p>两种办法，一种创建Calendar的子类的对象，第二种是使用getInstance静态方法返回一个子类的对象</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.Calendar;
<span class="hljs-keyword">import</span> java.util.Date;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Calendar cale = Calendar.getInstance();
        cale.get(Calendar.DAY_OF_WEEK);  <span class="hljs-comment">//int field，filed是Calendar类中定义的属性</span>
        System.out.println(cale.get(Calendar.DAY_OF_WEEK));
        System.out.println();
        cale.set(Calendar.DAY_OF_WEEK, <span class="hljs-number">5</span>);  <span class="hljs-comment">//int field, int value</span>
        System.out.println(cale.get(Calendar.DAY_OF_WEEK));

        cale.add(Calendar.DAY_OF_WEEK, <span class="hljs-number">3</span>);  <span class="hljs-comment">//int field, int value</span>
        System.out.println(cale.get(Calendar.DAY_OF_WEEK));

        Date date = cale.getTime();
        System.out.println(date);
        Date date2 = <span class="hljs-keyword">new</span> Date();
        cale.setTime(date2);  <span class="hljs-comment">//使用相应的日期重置</span>
        System.out.println(cale.get(Calendar.DAY_OF_WEEK));
    }
}
</div></code></pre>
<h4 id="jdk8%E4%B9%8B%E5%90%8E%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9Fapi">JDK8之后新的日期API</h4>
<h5 id="localdate%E7%B1%BBlocaltime%E7%B1%BBlocaldatetime%E7%B1%BB">LocalDate类，LocalTime类，LocalDateTime类</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.time.LocalDate;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;
<span class="hljs-keyword">import</span> java.time.LocalTime;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        LocalDate localDate = LocalDate.now();  <span class="hljs-comment">//获取当前的时间</span>
        LocalTime localTime = LocalTime.now();
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println(localDate);
        System.out.println(localTime);
        System.out.println(localDateTime);
        System.out.println();

        LocalDate localDate1 = LocalDate.of(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">28</span>);
        LocalDateTime localDateTime1 = LocalDateTime.of(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">28</span>, <span class="hljs-number">23</span>, <span class="hljs-number">55</span>, <span class="hljs-number">45</span>);
        System.out.println(localDate1);
        System.out.println(localDateTime1);
        System.out.println();
    }
}
</div></code></pre>
<h5 id="instant-%E7%9E%AC%E6%97%B6">Instant 瞬时</h5>
<p>Instant类是一个专门的时间戳类，常用于响应事件中</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.time.OffsetDateTime;
<span class="hljs-keyword">import</span> java.time.ZoneOffset;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Instant instant = Instant.now();
        System.out.println(instant);
        System.out.println();
        <span class="hljs-comment">//输出的结果是有偏差的，可以通过下列方式来调整</span>
        OffsetDateTime instant1 = instant.atOffset(ZoneOffset.ofHours(<span class="hljs-number">8</span>));  <span class="hljs-comment">//偏移量设置</span>
        System.out.println(instant1);
        System.out.println();

        Instant instant2 = Instant.ofEpochMilli(<span class="hljs-number">232323232323L</span>);  <span class="hljs-comment">//指定的年月日</span>
        System.out.println(instant2);

        <span class="hljs-keyword">long</span> millis = instant.toEpochMilli();  <span class="hljs-comment">//获取毫秒数</span>
    }
}
</div></code></pre>
<h5 id="datetimeformatter-%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96">DateTimeFormatter 日期格式化</h5>
<p>针对新的那三个类的格式化</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.time.LocalDateTime;
<span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;
<span class="hljs-keyword">import</span> java.time.temporal.TemporalAccessor;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
        LocalDateTime localDateTime = LocalDateTime.now();
        String strDateTime = dateTimeFormatter.format(localDateTime);
        System.out.println(strDateTime);

        System.out.println();
        TemporalAccessor temporalAccessor = dateTimeFormatter.parse(<span class="hljs-string">"2024-12-29 01:10:55"</span>);
        LocalDateTime localDateTime1 = LocalDateTime.from(temporalAccessor);
        System.out.println(localDateTime1);
    }
}
</div></code></pre>
<h3 id="%E6%AF%94%E8%BE%83%E5%99%A8">比较器</h3>
<h4 id="comparable-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F">Comparable 自然排序</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        YhLight[] arr = <span class="hljs-keyword">new</span> YhLight[<span class="hljs-number">5</span>];
        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight"</span>, <span class="hljs-number">18</span>);
        arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">19</span>);
        arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"zhanyang"</span>, <span class="hljs-number">20</span>);
        arr[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"lishiling"</span>, <span class="hljs-number">21</span>);
        arr[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"heh"</span>, <span class="hljs-number">18</span>);
        Arrays.sort(arr);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> YhLight) {
            YhLight yhLight = (YhLight) o;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.compareTo(yhLight.name);
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }
}
</div></code></pre>
<h4 id="comparator-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F">Comparator 定制排序</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.Comparator;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        YhLight[] arr = <span class="hljs-keyword">new</span> YhLight[<span class="hljs-number">5</span>];
        arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight"</span>, <span class="hljs-number">18</span>);
        arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">19</span>);
        arr[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"zhanyang"</span>, <span class="hljs-number">20</span>);
        arr[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"lishiling"</span>, <span class="hljs-number">21</span>);
        arr[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"heh"</span>, <span class="hljs-number">18</span>);

        Comparator comparator = <span class="hljs-keyword">new</span> Comparator() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>{
                <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> YhLight &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> YhLight) {
                    YhLight yhLight1 = (YhLight) o1;
                    YhLight yhLight2 = (YhLight) o2;
                    <span class="hljs-keyword">return</span> Integer.compare(yhLight1.getAge(), yhLight2.getAge());
                }
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
            }
        };

        Arrays.sort(arr, comparator);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> age;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }
}
</div></code></pre>
<h3 id="%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%B1%BB">其他常用类</h3>
<h4 id="system%E7%B1%BB">System类</h4>
<p><code>long currentTimeMillis()</code><br>
该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数</p>
<p><code>void exit(int status)</code><br>
该方法的作用是退出程序，其中status的值为0代表正常退出，非零代表异常退出，使用该方法可以在图形界面编程中实现程序的退出功能等</p>
<p><code>void gc()</code><br>
该方法的作用是请求系统进行垃圾回收，至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况</p>
<p><code>String getProperty(String key)</code><br>
该方法的作用是获得系统中属性名为key的属性对应的值</p>
<p><code>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code><br>
从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束，常用于数组的插入和删除</p>
<h4 id="runtime%E7%B1%BB">Runtime类</h4>
<p>每个Java应用程序都有一个<code>Runtime</code>类实例，使应用程序能够与其运行的环境相连接<br>
<code>public static Runtime getRuntime()</code>返回与当前Java应用程序相关的运行时对象，应用程序不能创建自己的Runtime类实例</p>
<p><code>public long totalMemory()</code>返回 Java 虚拟机中初始化时的内存总量，此方法返回的值可能随时间的推移而变化，这取决于主机环境，默认为物理电脑内存的1/64</p>
<p><code>public long maxMemory()</code>返回Java虚拟机中最大程度能使用的内存总量，默认为物理电脑内存的1/4</p>
<p><code>public long freeMemory()</code>返回Java虚拟机中的空闲内存量，调用gc方法可能导致freeMemory 返回值的增加</p>
<h4 id="math%E7%B1%BB">Math类</h4>
<p><code>public static double abs(double a)</code>返回double值的绝对值</p>
<p><code>public static double ceil(double a)</code>返回大于等于参数的最小的整数</p>
<p><code>public static double floor(double a)</code>返回小于等于参数最大的整数</p>
<p><code>public static long round(double a)</code>返回最接近参数的long，(相当于四舍五入方法)</p>
<p><code>public static double pow(double a,double b)</code>返回a的b幂次方法</p>
<p><code>public static double sqrt(double a)</code>返回a的平方根</p>
<p><code>public static double random()</code>返回[0,1)的随机值<br>
<code>public static final double PI</code>返回圆周率<br>
<code>public static double max(double x, double y)</code>返回x,y中的最大值<br>
<code>public static double min(double x, double y)</code>返回x,y中的最小值<br>
acos,asin,atan,cos,sin,tan三角函数</p>
<h4 id="biginteger%E7%B1%BB">BigInteger类</h4>
<p>Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1，如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了</p>
<p>java.math包的BigInteger可以表示<code>不可变的任意精度的整数</code>，BigInteger提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法，另外，BigInteger还提供以下运算：模算术、GCD计算、质数测试、素数生成、位操作以及一些其他操作</p>
<p>构造器<br>
<code>BigInteger(String val)</code> 根据字符串构建BigInteger对象</p>
<p><code>public BigInteger abs()</code> 返回此BigInteger的绝对值的BigInteger</p>
<p><code>BigInteger add(BigInteger val)</code> 返回增加val数值的BigInteger</p>
<p><code>BigInteger subtract(BigInteger val)</code> 返回减少val数值的BigInteger</p>
<p><code>BigInteger multiply(BigInteger val)</code> 返回乘于val数值的BigInteger</p>
<p><code>BigInteger divide(BigInteger val)</code> 返回除于val数值的BigInteger，结果保留整数</p>
<p><code>BigInteger remainder(BigInteger val)</code> 返回模于val数值的BigInteger，结果保留整数</p>
<p><code>BigInteger[] divideAndRemainder(BigInteger val)</code>  返回一个存储结果为除于和模于后的两个数的数组</p>
<p><code>BigInteger pow(int exponent)</code> 返回其值为exponent次方的BigInteger</p>
<h4 id="bigdecimal%E7%B1%BB">BigDecimal类</h4>
<p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类</p>
<p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数</p>
<p>构造器<br>
<code>public BigDecimal(double val)</code><br>
<code>public BigDecimal(String val)</code> 推荐</p>
<p>常用方法<br>
<code>public BigDecimal add(BigDecimal augend)</code><br>
<code>public BigDecimal subtract(BigDecimal subtrahend)</code><br>
<code>public BigDecimal multiply(BigDecimal multiplicand)</code><br>
<code>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</code><br>
divisor是除数，scale指明保留几位小数，roundingMode指明舍入模式（ROUND_UP :向上加1、ROUND_DOWN :直接舍去、ROUND_HALF_UP:四舍五入）</p>
<h4 id="random%E7%B1%BB">Random类</h4>
<p><code>boolean nextBoolean()</code>返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean值</p>
<p><code>void nextBytes(byte[] bytes)</code>生成随机字节并将其置于用户提供的byte数组中</p>
<p><code>double nextDouble()</code>返回下一个伪随机数，它是取自此随机数生成器序列的，在0.0和1.0之间均匀分布的double值</p>
<p><code>float nextFloat()</code>返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的float值</p>
<p><code>double nextGaussian()</code>返回下一个伪随机数，它是取自此随机数生成器序列的，呈高斯（“正态”）分布的double值，其平均值是0.0，标准差是1.0</p>
<p><code>int nextInt()</code>返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的int值</p>
<p><code>int nextInt(int n)</code>返回一个伪随机数，它是取自此随机数生成器序列的，在0（包括）和指定值（不包括）之间均匀分布的int值</p>
<p><code>long nextLong()</code>返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的long值</p>
<h2 id="%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">集合框架</h2>
<p>集合可分为Collection和Map两大体系</p>
<p>Collection接口  用于存储一个一个的数据，也称<code>单列数据集合</code></p>
<ul>
<li>List子接口  用来存储有序的，可以重复的数据（主要用来替换数组，动态数组）
<ul>
<li>实现类  ArrayList(主要实现类)，LinkedList，Vector</li>
</ul>
</li>
<li>Set子接口  用来存储无序的，不可重复的数据（类似于高中讲的集合）
<ul>
<li>实现类  HashSet(主要实现类)，LinkedHashSet，TreeSet</li>
</ul>
</li>
</ul>
<p>Map接口  用于存储具有映射关系key-value对的集合，即一对一对的数据，也称<code>双列数据集合</code>，(类似于高中的函数，映射，(x1, y1),(x2, y2) ---&gt; y = f(x))</p>
<ul>
<li>HashMap(主要实现类)，LinkedHashMap，TreeMap，Hashtable，Properties</li>
</ul>
<h3 id="collection%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95">Collection中的方法</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Collection coll1 = <span class="hljs-keyword">new</span> ArrayList();

        <span class="hljs-comment">//add(E obj)：添加元素对象到当前集合中</span>
        <span class="hljs-comment">//addAll(Collection other)：添加other集合中的所有元素对象到当前集合中</span>
        coll1.add(<span class="hljs-string">"yhlight"</span>);
        coll1.add(<span class="hljs-number">1145145</span>);
        coll1.add(<span class="hljs-string">"HelloWorld"</span>);
        coll1.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">19</span>));
        System.out.println(coll1);
        System.out.println();

        Collection coll2 = <span class="hljs-keyword">new</span> ArrayList();
        coll2.addAll(coll1);
        coll2.add(<span class="hljs-string">"myLove"</span>);
        System.out.println(coll2);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//int size()：获取当前集合中实际存储的元素个数</span>
        <span class="hljs-comment">//boolean isEmpty()：判断当前集合是否为空集合</span>
        <span class="hljs-comment">//boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素</span>
        <span class="hljs-comment">//boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在，即coll集合是否是当前集合的“子集”</span>
        <span class="hljs-comment">//boolean equals(Object obj)：判断当前集合与obj是否相等</span>

        System.out.println();
        Collection coll1 = <span class="hljs-keyword">new</span> ArrayList();
        coll1.add(<span class="hljs-string">"yhlight"</span>);
        coll1.add(<span class="hljs-number">1145145</span>);
        coll1.add(<span class="hljs-string">"HelloWorld"</span>);
        coll1.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">19</span>));
        System.out.println(coll1.size());
        System.out.println(coll1);

        Collection coll2 = <span class="hljs-keyword">new</span> ArrayList();
        System.out.println(coll2.isEmpty());

        coll2.add(<span class="hljs-string">"yhlight"</span>);
        System.out.println(coll2.contains(<span class="hljs-string">"yhlight"</span>));  <span class="hljs-comment">//比较的是内容</span>
        coll2.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">19</span>));
        System.out.println(coll2.contains(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">19</span>)));  <span class="hljs-comment">//没有重写equals，为否</span>
        System.out.println(coll2.containsAll(coll1));
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//void clear()：清空集合元素</span>
        <span class="hljs-comment">//boolean remove(Object obj)：从当前集合中删除第一个找到的与obj对象equals返回true的元素</span>
        <span class="hljs-comment">//boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素</span>
        <span class="hljs-comment">//boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素</span>

        System.out.println();
        Collection coll1 = <span class="hljs-keyword">new</span> ArrayList();
        coll1.add(<span class="hljs-string">"yhlight"</span>);
        System.out.println(coll1);
        coll1.clear();
        System.out.println(coll1);

        coll1.add(<span class="hljs-string">"yhlight"</span>);
        coll1.add(<span class="hljs-number">1145145</span>);
        coll1.add(<span class="hljs-string">"HelloWorld"</span>);
        coll1.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">19</span>));
        coll1.remove(<span class="hljs-number">1145145</span>);
        System.out.println(coll1);

        Collection coll2 = <span class="hljs-keyword">new</span> ArrayList();
        coll2.add(<span class="hljs-string">"yhlight"</span>);
        coll2.add(<span class="hljs-string">"HelloWorld"</span>);
        coll1.removeAll(coll2);
        System.out.println(coll1);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//Object[] toArray()：返回包含当前集合中所有元素的数组</span>
        <span class="hljs-comment">//hashCode()：获取集合对象的哈希值</span>
        <span class="hljs-comment">//iterator()：返回迭代器对象，用于集合遍历</span>
        System.out.println();
        String[] arr = <span class="hljs-keyword">new</span> String[]{<span class="hljs-string">"yhlight"</span>, <span class="hljs-string">"shuiyang"</span>, <span class="hljs-string">"toLove"</span>};
        Collection list = Arrays.asList(arr);
        System.out.println(list);

        Object[] array = list.toArray();
        <span class="hljs-comment">//转换思路</span>
        <span class="hljs-comment">//String[] array = (String[]) list.toArray(new String[0]);</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) {
            System.out.println(array[i]);
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

<span class="hljs-comment">//    @Override</span>
<span class="hljs-comment">//    public boolean equals(Object obj) {</span>
<span class="hljs-comment">//        if (obj == this) {</span>
<span class="hljs-comment">//            return true;</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//        if (obj instanceof YhLight) {</span>
<span class="hljs-comment">//            YhLight yhLight = (YhLight) obj;</span>
<span class="hljs-comment">//            return this.name.equals(yhLight.name) &amp;&amp; this.age == yhLight.age;</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//        return false;  //注意，这里因为使用了new YhLight，所以不能使用抛出异常</span>
<span class="hljs-comment">//    }</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> YhLight yhLight)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> age == yhLight.age &amp;&amp; Objects.equals(name, yhLight.name);
    }
}
</div></code></pre>
<p>add(E obj)：添加元素对象到当前集合中</p>
<p>addAll(Collection other)：添加other集合中的所有元素对象到当前集合中</p>
<p>int size()：获取当前集合中实际存储的元素个数</p>
<p>boolean isEmpty()：判断当前集合是否为空集合</p>
<p>boolean contains(Object obj)：判断当前集合中是否存在一个与obj对象equals返回true的元素</p>
<p>boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在，即coll集合是否是当前集合的“子集”</p>
<p>boolean equals(Object obj)：判断当前集合与obj是否相等</p>
<p>void clear()：清空集合元素</p>
<p>boolean remove(Object obj)：从当前集合中删除第一个找到的与obj对象equals返回true的元素</p>
<p>boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素</p>
<p>boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素</p>
<p>Object[] toArray()：返回包含当前集合中所有元素的数组</p>
<p>hashCode()：获取集合对象的哈希值</p>
<p>iterator()：返回迭代器对象，用于集合遍历</p>
<h3 id="iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8">Iterator 迭代器</h3>
<p>Iterator接口是用来迭代集合元素的</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.Objects;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Collection coll = <span class="hljs-keyword">new</span> ArrayList();
        coll.add(<span class="hljs-string">"yhlight"</span>);
        coll.add(<span class="hljs-number">1145</span>);
        coll.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight"</span>, <span class="hljs-number">18</span>));

        Iterator iterator = coll.iterator();
<span class="hljs-comment">//        System.out.println(iterator.next());</span>
<span class="hljs-comment">//        System.out.println(iterator.next());</span>
<span class="hljs-comment">//        System.out.println(iterator.next());</span>
<span class="hljs-comment">//        System.out.println();</span>

        <span class="hljs-keyword">while</span> (iterator.hasNext()) {
            System.out.println(iterator.next());
        }

        System.out.println();
        Collection coll2 = <span class="hljs-keyword">new</span> ArrayList();
        coll2.add(<span class="hljs-string">"yhlight"</span>);
        coll2.add(<span class="hljs-string">"shuiyang"</span>);
        coll2.add(<span class="hljs-string">"huanting"</span>);

        Iterator iterator2 = coll2.iterator();
        <span class="hljs-keyword">while</span> (iterator2.hasNext()) {
            String str = (String) iterator2.next();
            <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">"shuiyang"</span>)) {
                iterator2.remove();  <span class="hljs-comment">//更安全的移除元素</span>
            }
            System.out.println(str);
        }
        System.out.println(coll2);
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> YhLight yhLight)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> age == yhLight.age &amp;&amp; Objects.equals(name, yhLight.name);
    }
}
</div></code></pre>
<h4 id="%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF">增强for循环</h4>
<p>jdk5.0的特性，可以用来遍历数组或集合</p>
<pre class="hljs"><code><div>        <span class="hljs-keyword">for</span> (类型 变量 : 容器) {
        }
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.Objects;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Collection coll = <span class="hljs-keyword">new</span> ArrayList();
        coll.add(<span class="hljs-string">"yhlight"</span>);
        coll.add(<span class="hljs-number">1145</span>);
        coll.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight"</span>, <span class="hljs-number">18</span>));

        <span class="hljs-keyword">for</span> (Object obj : coll) {
            System.out.println(obj);
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

<span class="hljs-comment">//    @Override</span>
<span class="hljs-comment">//    public boolean equals(Object obj) {</span>
<span class="hljs-comment">//        if (obj == this) {</span>
<span class="hljs-comment">//            return true;</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//        if (obj instanceof YhLight) {</span>
<span class="hljs-comment">//            YhLight yhLight = (YhLight) obj;</span>
<span class="hljs-comment">//            return this.name.equals(yhLight.name) &amp;&amp; this.age == yhLight.age;</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//        return false;  //注意，这里因为使用了new YhLight，所以不能使用抛出异常</span>
<span class="hljs-comment">//    }</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> YhLight yhLight)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> age == yhLight.age &amp;&amp; Objects.equals(name, yhLight.name);
    }
}
</div></code></pre>
<h3 id="list%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">List接口常用方法</h3>
<p>void add(int index, Object ele)  在index位置插入ele元素</p>
<p>boolean addAll(int index, Collection eles)  从index位置开始将eles中的所有元素添加进来</p>
<p>Object get(int index)  获取指定index位置的元素</p>
<p>List subList(int fromIndex, int toIndex)  返回从fromIndex到toIndex位置的子集合</p>
<p>int indexOf(Object obj)  返回obj在集合中首次出现的位置</p>
<p>int lastIndexOf(Object obj)  返回obj在当前集合中末次出现的位置</p>
<p>Object remove(int index)  移除指定index位置的元素，并返回此元素</p>
<p>Object set(int index, Object ele)  设置指定index位置的元素为ele</p>
<h3 id="list%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">List不同实现类之间的区别</h3>
<h4 id="arraylist">ArrayList</h4>
<p>ArrayList线程不安全，效率高，但是有办法处理线程不安全问题，底层使用Object[]数组<br>
在添加，查找数据时，效率较高，在插入，删除数据时，效率较低</p>
<h4 id="vector">Vector</h4>
<p>Vector线程安全，效率低，很古老的一个类，所以基本不会用，底层使用Object[]数组</p>
<h4 id="linkedlist">LinkedList</h4>
<p>如果需要频繁插入，删除元素，那么使用LinkedList，效率较高，底层使用双向链表<br>
在添加，查找数据时，效率较低，在插入，删除数据时，效率较高</p>
<h3 id="set%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">Set不同实现类之间的区别</h3>
<p>Set常用于过滤重复数据</p>
<h4 id="hashset">HashSet</h4>
<p>底层使用HashMap，HashMap底层使用数组+单向链表+红黑树结构（Jdk8）结构存储<br>
HashSet中的元素的比较需要同时满足hashCode()和equals(Object obj)，只有这两个同时成立才算相等</p>
<p>Set的无序性并不等同于随机性，我们在添加每一个元素到数组中时，具体的存储位置是由元素的hashCode()调用后返回的hash值决定的，导致在数组中每个元素不是依次紧密存放的，从而表现出一定的无序性</p>
<p>Set的不可重复是通过判断hashCode()得到的哈希值以及equlas()得到的结果来确认元素是否相同</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Objects;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Set set = <span class="hljs-keyword">new</span> HashSet();
        set.add(<span class="hljs-string">"yhlight"</span>);
        set.add(<span class="hljs-number">114514</span>);
        set.add(<span class="hljs-string">"shuiyang"</span>);
        set.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">20</span>));

        System.out.println(set.contains(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">20</span>)));  <span class="hljs-comment">//注意，这里要重写hashCode方法，否则为false</span>
        System.out.println(set);
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> </span>{
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> YhLight yhLight)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> age == yhLight.age &amp;&amp; Objects.equals(name, yhLight.name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Objects.hash(name, age);
    }
}
</div></code></pre>
<h4 id="linkhashset">LinkHashSet</h4>
<p>HashSet的子类，相较于HashMap，还多了一组双向链表来存储，可以记录添加元素的先后顺序，可以用于频繁的查询操作</p>
<h4 id="treeset">TreeSet</h4>
<p>底层使用红黑树来存储，可以按照添加的元素指定的属性的大小顺序来遍历</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.Objects;
<span class="hljs-keyword">import</span> java.util.TreeSet;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        TreeSet set = <span class="hljs-keyword">new</span> TreeSet();  <span class="hljs-comment">//可以传入一个定制排序作为排序的样式</span>
        set.add(<span class="hljs-string">"CC"</span>);
        set.add(<span class="hljs-string">"BB"</span>);
        set.add(<span class="hljs-string">"AA"</span>);
        set.add(<span class="hljs-string">"FF"</span>);
        set.add(<span class="hljs-string">"SS"</span>);
        set.add(<span class="hljs-string">"DD"</span>);

        Iterator iterator = set.iterator();
        <span class="hljs-keyword">while</span> (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
</div></code></pre>
<p>使用TreeSet需要注意使用比较器<br>
TreeSet进行比较不再考虑HashCode和equals，而是使用自然排序和定义排序，看这两个中的compareTo方法的结果</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.Objects;
<span class="hljs-keyword">import</span> java.util.TreeSet;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        HashSet set = <span class="hljs-keyword">new</span> HashSet();
        YhLight y1 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"Yhlight"</span>, <span class="hljs-number">18</span>);
        YhLight y2 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">20</span>);

        set.add(y1);
        set.add(y2);
        System.out.println(set);

        y1.name = <span class="hljs-string">"yinghuolight"</span>;  <span class="hljs-comment">//哈希值变了，所以删除不了</span>
        set.remove(y1);  <span class="hljs-comment">//注意这里，remove是查阅之前add添加进来时的哈希值</span>
        <span class="hljs-comment">//改变y1属性，导致哈希值改变，但是删除时仍然去寻找旧的哈希值，所以删除失败</span>
        System.out.println(set);
        set.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yinghuolight"</span>, <span class="hljs-number">18</span>));
        System.out.println(set);
        set.add(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"Yhlight"</span>, <span class="hljs-number">18</span>));
        System.out.println(set);

<span class="hljs-comment">//        Iterator iterator = set.iterator();</span>
<span class="hljs-comment">//        while (iterator.hasNext()) {</span>
<span class="hljs-comment">//            System.out.println(iterator.next());</span>
<span class="hljs-comment">//        }</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> </span>{
    String name;
    <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> YhLight yhLight)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> age == yhLight.age &amp;&amp; Objects.equals(name, yhLight.name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Objects.hash(name, age);
    }
}
</div></code></pre>
<h3 id="map%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94">Map不同实现类之间的对比</h3>
<h4 id="hashmap">HashMap</h4>
<p>主要实现类，线程不安全，可以添加为null的key和value值，底层使用数组+单向链表+红黑树结构存储<br>
key所在的类，需要重写HashCode()和equals()方法，而value不需要重写HashCode()，但是默认重写两个</p>
<h5 id="linkedhashmap">LinkedHashMap</h5>
<p>HashMap的子类，在HashMap使用的数据结构的基础上，增加了一对双向链表，用于记录添加的元素的先后顺序<br>
进而我们在遍历元素时，就可以按照添加的顺序显示，开发中，对于频繁的遍历操作，建议使用此类</p>
<h5 id="map%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">Map常用方法</h5>
<p>Object put(Object key,Object value)  将指定key-value添加到(或修改)当前map对象中</p>
<p>void putAll(Map m)  将m中的所有key-value对存放到当前map中</p>
<p>Object remove(Object key)  移除指定key的key-value对，并返回value</p>
<p>void clear()  清空当前map中的所有数据</p>
<p>Object get(Object key)  获取指定key对应的value</p>
<p>boolean containsKey(Object key)  是否包含指定的key</p>
<p>boolean containsValue(Object value)  是否包含指定的value</p>
<p>int size()  返回map中key-value对的个数</p>
<p>boolean isEmpty()  判断当前map是否为空</p>
<p>boolean equals(Object obj)  判断当前map和参数对象obj是否相等</p>
<p>Set keySet()  返回所有key构成的Set集合</p>
<p>Collection values()  返回所有value构成的Collection集合</p>
<p>Set entrySet()  返回所有key-value对构成的Set集合</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Map map = <span class="hljs-keyword">new</span> HashMap();
        map.put(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">23</span>);
        map.put(<span class="hljs-number">34</span>, <span class="hljs-string">"AA"</span>);
        map.put(<span class="hljs-string">"CC"</span>, <span class="hljs-keyword">new</span> Date());
        System.out.println(map);

        Set set = map.entrySet();
        Iterator iterator = set.iterator();
        <span class="hljs-keyword">while</span> (iterator.hasNext()) {
            Map.Entry entry = (Map.Entry) iterator.next();
            System.out.println(entry.getKey() + <span class="hljs-string">"------&gt;"</span> + entry.getValue());
        }
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{

    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> </span>{
    String name;
    <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> YhLight yhLight)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> age == yhLight.age &amp;&amp; Objects.equals(name, yhLight.name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Objects.hash(name, age);
    }
}
</div></code></pre>
<h4 id="hashtable">Hashtable</h4>
<p>古老实现类，线程安全</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Hashtable;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        Map map = <span class="hljs-keyword">new</span> HashMap();
        map.put(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);
        System.out.println(map);
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        Map map = <span class="hljs-keyword">new</span> Hashtable();
<span class="hljs-comment">//        map.put(null,123);</span>
<span class="hljs-comment">//        System.out.println(map);  //报错</span>

<span class="hljs-comment">//        map.put("AA",null);</span>
<span class="hljs-comment">//        System.out.println(map);  //报错</span>
<span class="hljs-comment">//        没有HashMap那么健壮性好</span>
    }
}
</div></code></pre>
<h4 id="treemap">TreeMap</h4>
<p>底层使用红黑树来存储，可以按照添加的元素指定的属性的大小顺序来遍历<br>
向TreeMap添加的key必须为同一类型</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.Comparator;
<span class="hljs-keyword">import</span> java.util.Objects;
<span class="hljs-keyword">import</span> java.util.Set;
<span class="hljs-keyword">import</span> java.util.TreeMap;


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        TreeMap map = <span class="hljs-keyword">new</span> TreeMap();

        map.put(<span class="hljs-string">"yhlight"</span>, <span class="hljs-number">18</span>);
        map.put(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">20</span>);
        map.put(<span class="hljs-string">"toLove"</span>, <span class="hljs-number">0</span>);

        Set set = map.entrySet();
        <span class="hljs-keyword">for</span> (Object obj : set) {
            System.out.println(obj);
        }
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        YhLight yhLight1 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight"</span>, <span class="hljs-number">18</span>);
        YhLight yhLight2 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">20</span>);
        YhLight yhLight3 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"toLove"</span>, <span class="hljs-number">0</span>);

        TreeMap map = <span class="hljs-keyword">new</span> TreeMap();
        map.put(yhLight1, <span class="hljs-number">100</span>);
        map.put(yhLight2, <span class="hljs-number">100</span>);
        map.put(yhLight3, <span class="hljs-string">"max"</span>);

        System.out.println();
        Set set = map.entrySet();
        <span class="hljs-keyword">for</span> (Object obj : set) {
            System.out.println(obj);
        }
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//这里使用第二个比较方法</span>
        YhLight yhLight1 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight1"</span>, <span class="hljs-number">18</span>);  <span class="hljs-comment">//注意，比较的是年龄，这里年龄重复了</span>
        YhLight yhLight2 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">20</span>);
        YhLight yhLight3 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"toLove"</span>, <span class="hljs-number">0</span>);
        YhLight yhLight4 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight2"</span>, <span class="hljs-number">18</span>);
        <span class="hljs-comment">//TreeMap依靠compareTo方法进行比较，这里只是比较年龄，所以当出现年龄相等的情况，会认为后面添加的这个和前面重复了</span>
        <span class="hljs-comment">//Object put(Object key,Object value)  将指定key-value添加到(或修改)当前map对象中</span>
        <span class="hljs-comment">//put方法能够修改值，这里就是出现了这样的情况，误以为yhLight4==yhLight1了</span>

        TreeMap map = <span class="hljs-keyword">new</span> TreeMap();
        map.put(yhLight1, <span class="hljs-number">100</span>);
        map.put(yhLight2, <span class="hljs-number">100</span>);
        map.put(yhLight3, <span class="hljs-string">"max"</span>);
        map.put(yhLight4, <span class="hljs-number">150</span>);

        System.out.println();
        Set set = map.entrySet();
        <span class="hljs-keyword">for</span> (Object obj : set) {
            System.out.println(obj);
        }

        System.out.println(map.containsKey(<span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"注意看"</span>, <span class="hljs-number">20</span>)));
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>{
        Comparator comparator = <span class="hljs-keyword">new</span> Comparator() {
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Object o1, Object o2)</span> </span>{
                <span class="hljs-keyword">if</span> (o1 <span class="hljs-keyword">instanceof</span> YhLight &amp;&amp; o2 <span class="hljs-keyword">instanceof</span> YhLight) {
                    YhLight yhLight1 = (YhLight) o1;
                    YhLight yhLight2 = (YhLight) o2;
                    <span class="hljs-keyword">return</span> yhLight1.age - yhLight2.age;
                }
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
            }
        };

        TreeMap map = <span class="hljs-keyword">new</span> TreeMap(comparator);

        YhLight yhLight1 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"yhlight"</span>, <span class="hljs-number">18</span>);
        YhLight yhLight2 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"shuiyang"</span>, <span class="hljs-number">20</span>);
        YhLight yhLight3 = <span class="hljs-keyword">new</span> YhLight(<span class="hljs-string">"toLove"</span>, <span class="hljs-number">0</span>);
        map.put(yhLight1, <span class="hljs-number">100</span>);
        map.put(yhLight2, <span class="hljs-number">100</span>);
        map.put(yhLight3, <span class="hljs-string">"max"</span>);

        System.out.println();
        Set set = map.entrySet();
        <span class="hljs-keyword">for</span> (Object obj : set) {
            System.out.println(obj);
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YhLight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span> </span>{
    String name;
    <span class="hljs-keyword">int</span> age;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">()</span> </span>{

    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">YhLight</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.age = age;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"YhLight{"</span> +
                <span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
                <span class="hljs-string">", age="</span> + age +
                <span class="hljs-string">'}'</span>;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> YhLight yhLight)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">return</span> age == yhLight.age &amp;&amp; Objects.equals(name, yhLight.name);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Objects.hash(name, age);
    }

<span class="hljs-comment">//    @Override</span>
<span class="hljs-comment">//    public int compareTo(Object o) {</span>
<span class="hljs-comment">//        if (this == o) {</span>
<span class="hljs-comment">//            return 0;</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//        if (o instanceof YhLight) {</span>
<span class="hljs-comment">//            YhLight yhLight = (YhLight) o;</span>
<span class="hljs-comment">//            return this.name.compareTo(yhLight.name);</span>
<span class="hljs-comment">//        }</span>
<span class="hljs-comment">//        throw new RuntimeException();</span>
<span class="hljs-comment">//    }</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> YhLight) {
            YhLight yhLight = (YhLight) o;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age - yhLight.age;
        }
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();
    }
}
</div></code></pre>
<h5 id="properties">Properties</h5>
<p>其key和value都是String类型，常用于处理属性文件</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.io.File;
<span class="hljs-keyword">import</span> java.io.FileInputStream;
<span class="hljs-keyword">import</span> java.io.FileNotFoundException;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.Properties;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"info.properties"</span>);
        System.out.println(file.getAbsolutePath());
        FileInputStream fis = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">try</span> {
            fis = <span class="hljs-keyword">new</span> FileInputStream(file);
        } <span class="hljs-keyword">catch</span> (FileNotFoundException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
        Properties pros = <span class="hljs-keyword">new</span> Properties();
        <span class="hljs-keyword">try</span> {
            pros.load(fis);
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
        String name = pros.getProperty(<span class="hljs-string">"name"</span>);
        String password = pros.getProperty(<span class="hljs-string">"password"</span>);

        System.out.println(<span class="hljs-string">"姓名:"</span> + name + <span class="hljs-string">" 密码:"</span> + password);

        <span class="hljs-keyword">try</span> {
            fis.close();
        } <span class="hljs-keyword">catch</span> (IOException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);
        }
    }
}
</div></code></pre>
<h4 id="collections%E5%B7%A5%E5%85%B7%E7%B1%BB">Collections工具类</h4>
<p>Collections是一个操作Set、List和Map等集合的工具类</p>
<p>reverse(List)  反转 List 中元素的顺序</p>
<p>shuffle(List)  对 List 集合元素进行随机排序</p>
<p>sort(List)  根据元素的自然顺序对指定List集合元素按升序排序</p>
<p>sort(List ，Comparator)  根据指定的Comparator产生的顺序对List集合元素进行排序</p>
<p>swap(List list ，int i ， int j)：将指定list集合中的i处元素和j处元素进行交换</p>
<p>Object max(Collection)  根据元素的自然顺序，返回给定集合中的最大元素</p>
<p>Object max(Collection ，Comparator)  根据Comparator指定的顺序，返回给定集合中的最大元素</p>
<p>Object min(Collection)  根据元素的自然顺序，返回给定集合中的最小元素</p>
<p>Object min(Collection ，Comparator)  根据Comparator指定的顺序，返回给定集合中的最小元素</p>
<p>int binarySearch(List list , T key)  在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定</p>
<p>int binarySearch(List list , T key , Comparator c)  在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定</p>
<p>int frequency(Collection c，Object o)  返回指定集合中指定元素的出现次数</p>
<p>void copy(List dest , List src)  将src中的内容复制到dest中<br>
直接用容易报错，集合初始的容量是10，超过会报错</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArbitraryTest</span> </span>{
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>{
        List list = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">54</span>, <span class="hljs-number">254</span>, <span class="hljs-number">623</span>, <span class="hljs-number">325</span>, <span class="hljs-number">26</span>, <span class="hljs-number">2547</span>, <span class="hljs-number">357</span>, <span class="hljs-number">357</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">54</span>);
        List newArr = Arrays.asList(<span class="hljs-keyword">new</span> Object[list.size()]);
        Collections.copy(newArr, list);
        System.out.println(newArr);
    }
}
</div></code></pre>
<p>boolean replaceAll(List list , Object oldVal , Object newVal)  使用新值替换List对象的所有旧值</p>
<p>unmodifiableXxx()  用于返回一个不可变的集合</p>
<p>boolean addAll(Collection  c , T... elements)  将所有指定元素添加到指定collection中</p>
<p>synchronizedXxx()  该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
<h2 id="%E6%B3%9B%E5%9E%8B">泛型</h2>

</body>
</html>
